

<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../../_static/CveExplore_icon.png">
    
    
      
        <title>sqlalchemy.orm.session - CveXplore</title>
      
    
    
      
        
        
      
      

    
    
    
      
        
        
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
        <link rel="stylesheet" type="text/css" href="../../../_static/sphinx_immaterial_theme.e0b5691b38cca82da.min.css?v=b1736040" />
        <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=df571175" />
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="blue-grey" data-md-color-accent="light-blue">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../index.html" title="CveXplore" class="md-header__button md-logo" aria-label="CveXplore" data-md-component="logo">
      <img src="../../../_static/CveExplore_icon.png" alt="logo">
    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            CveXplore
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              sqlalchemy.orm.session
            
          </span>
        </div>
      </div>
    </div>
    
      <form class="md-header__option" data-md-component="palette">
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="blue-grey" data-md-color-accent="light-blue"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
          
            <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 1 7 7c0 2.38-1.19 4.47-3 5.74V17a1 1 0 0 1-1 1H9a1 1 0 0 1-1-1v-2.26C6.19 13.47 5 11.38 5 9a7 7 0 0 1 7-7M9 21v-1h6v1a1 1 0 0 1-1 1h-4a1 1 0 0 1-1-1m3-17a5 5 0 0 0-5 5c0 2.05 1.23 3.81 3 4.58V16h4v-2.42c1.77-.77 3-2.53 3-4.58a5 5 0 0 0-5-5Z"/></svg>
            </label>
          
        
          
          
          <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="blue-grey" data-md-color-accent="lime"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
          
            <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 2a7 7 0 0 0-7 7c0 2.38 1.19 4.47 3 5.74V17a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-2.26c1.81-1.27 3-3.36 3-5.74a7 7 0 0 0-7-7M9 21a1 1 0 0 0 1 1h4a1 1 0 0 0 1-1v-1H9v1Z"/></svg>
            </label>
          
        
      </form>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
          <a href="javascript:void(0)" class="md-search__icon md-icon" title="Share" aria-label="Share" data-clipboard data-clipboard-text="" data-md-component="search-share" tabindex="-1">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7 0-.24-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91 1.61 0 2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08Z"/></svg>
          </a>
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/cve-search/CveXplore" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    CveXplore
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../index.html" title="CveXplore" class="md-nav__button md-logo" aria-label="CveXplore" data-md-component="logo">
      <img src="../../../_static/CveExplore_icon.png" alt="logo">
    </a>
    CveXplore
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/cve-search/CveXplore" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
  </div>
  <div class="md-source__repository">
    CveXplore
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_1" type="checkbox" id="__nav_1" checked>
      
      
      
        <label class="md-nav__link" for="__nav_1">
          <span class="md-ellipsis">General:<wbr></span>
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="General:" data-md-level="1">
        <label class="md-nav__title" for="__nav_1">
          <span class="md-nav__icon md-icon"></span>
          <span class="md-ellipsis">General:<wbr></span>
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../general/general.html" class="md-nav__link">
        <span class="md-ellipsis">Dependencies</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../general/settings.html" class="md-nav__link">
        <span class="md-ellipsis">Settings</span>
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_2" type="checkbox" id="__nav_2" checked>
      
      
      
        <label class="md-nav__link" for="__nav_2">
          <span class="md-ellipsis">Database:<wbr></span>
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Database:" data-md-level="1">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          <span class="md-ellipsis">Database:<wbr></span>
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../database/models.html" class="md-nav__link">
        <span class="md-ellipsis">SQL Models</span>
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_3" type="checkbox" id="__nav_3" checked>
      
      
      
        <label class="md-nav__link" for="__nav_3">
          <span class="md-ellipsis">Package:<wbr></span>
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Package:" data-md-level="1">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          <span class="md-ellipsis">Package:<wbr></span>
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../package/query_data.html" class="md-nav__link">
        <span class="md-ellipsis">Query for data</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../package/code_base.html" class="md-nav__link">
        <span class="md-ellipsis">Code base</span>
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" checked>
      
      
      
        <label class="md-nav__link" for="__nav_4">
          <span class="md-ellipsis">Command line:<wbr></span>
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Command line:" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          <span class="md-ellipsis">Command line:<wbr></span>
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../cli/general.html" class="md-nav__link">
        <span class="md-ellipsis">General</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../cli/cli.html" class="md-nav__link">
        <span class="md-ellipsis">Command Line Interpreter</span>
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle md-toggle--indeterminate" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" checked>
      
      
      
        <label class="md-nav__link" for="__nav_5">
          <span class="md-ellipsis">Backend:<wbr></span>
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Backend:" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          <span class="md-ellipsis">Backend:<wbr></span>
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../backend/general.html" class="md-nav__link">
        <span class="md-ellipsis">General</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../backend/installation.html" class="md-nav__link">
        <span class="md-ellipsis">Installation</span>
      </a>
    </li>
  

            
          
            
              
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../backend/settings.html" class="md-nav__link">
        <span class="md-ellipsis">Settings</span>
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary">
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset" role="main">
                  


  <a href="https://github.com/cve-search/CveXplore/blob/master/docs/_modules/sqlalchemy/orm/session.rst" title="Edit this page" class="md-content__button md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4v-2m10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1 2.1 2.1Z"/></svg>
  </a>

<h1>Source code for sqlalchemy.orm.session</h1><div class="highlight"><pre>
<span></span><code><span class="c1"># orm/session.py</span>
<span class="c1"># Copyright (C) 2005-2024 the SQLAlchemy authors and contributors</span>
<span class="c1"># &lt;see AUTHORS file&gt;</span>
<span class="c1">#</span>
<span class="c1"># This module is part of SQLAlchemy and is released under</span>
<span class="c1"># the MIT License: https://www.opensource.org/licenses/mit-license.php</span>

<span class="sd">&quot;&quot;&quot;Provides the Session class and related utilities.&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">cast</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generic</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterator</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">NoReturn</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">overload</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Set</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Type</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TYPE_CHECKING</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypeVar</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">attributes</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">bulk_persistence</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">context</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">descriptor_props</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">exc</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">identity</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">loading</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">query</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">state</span> <span class="k">as</span> <span class="n">statelib</span>
<span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">_O</span>
<span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">insp_is_mapper</span>
<span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">is_composite_class</span>
<span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">is_orm_option</span>
<span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">is_user_defined_option</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">_class_to_mapper</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">_none_set</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">_state_mapper</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">instance_str</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">LoaderCallableStatus</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">object_mapper</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">object_state</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">PassiveFlag</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">state_str</span>
<span class="kn">from</span> <span class="nn">.context</span> <span class="kn">import</span> <span class="n">FromStatement</span>
<span class="kn">from</span> <span class="nn">.context</span> <span class="kn">import</span> <span class="n">ORMCompileState</span>
<span class="kn">from</span> <span class="nn">.identity</span> <span class="kn">import</span> <span class="n">IdentityMap</span>
<span class="kn">from</span> <span class="nn">.query</span> <span class="kn">import</span> <span class="n">Query</span>
<span class="kn">from</span> <span class="nn">.state</span> <span class="kn">import</span> <span class="n">InstanceState</span>
<span class="kn">from</span> <span class="nn">.state_changes</span> <span class="kn">import</span> <span class="n">_StateChange</span>
<span class="kn">from</span> <span class="nn">.state_changes</span> <span class="kn">import</span> <span class="n">_StateChangeState</span>
<span class="kn">from</span> <span class="nn">.state_changes</span> <span class="kn">import</span> <span class="n">_StateChangeStates</span>
<span class="kn">from</span> <span class="nn">.unitofwork</span> <span class="kn">import</span> <span class="n">UOWTransaction</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">engine</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">exc</span> <span class="k">as</span> <span class="n">sa_exc</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">sql</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">..engine</span> <span class="kn">import</span> <span class="n">Connection</span>
<span class="kn">from</span> <span class="nn">..engine</span> <span class="kn">import</span> <span class="n">Engine</span>
<span class="kn">from</span> <span class="nn">..engine.util</span> <span class="kn">import</span> <span class="n">TransactionalContext</span>
<span class="kn">from</span> <span class="nn">..event</span> <span class="kn">import</span> <span class="n">dispatcher</span>
<span class="kn">from</span> <span class="nn">..event</span> <span class="kn">import</span> <span class="n">EventTarget</span>
<span class="kn">from</span> <span class="nn">..inspection</span> <span class="kn">import</span> <span class="n">inspect</span>
<span class="kn">from</span> <span class="nn">..inspection</span> <span class="kn">import</span> <span class="n">Inspectable</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="kn">import</span> <span class="n">coercions</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="kn">import</span> <span class="n">dml</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="kn">import</span> <span class="n">roles</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="kn">import</span> <span class="n">Select</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="kn">import</span> <span class="n">TableClause</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="kn">import</span> <span class="n">visitors</span>
<span class="kn">from</span> <span class="nn">..sql.base</span> <span class="kn">import</span> <span class="n">_NoArg</span>
<span class="kn">from</span> <span class="nn">..sql.base</span> <span class="kn">import</span> <span class="n">CompileState</span>
<span class="kn">from</span> <span class="nn">..sql.schema</span> <span class="kn">import</span> <span class="n">Table</span>
<span class="kn">from</span> <span class="nn">..sql.selectable</span> <span class="kn">import</span> <span class="n">ForUpdateArg</span>
<span class="kn">from</span> <span class="nn">..sql.selectable</span> <span class="kn">import</span> <span class="n">LABEL_STYLE_TABLENAME_PLUS_COL</span>
<span class="kn">from</span> <span class="nn">..util</span> <span class="kn">import</span> <span class="n">IdentitySet</span>
<span class="kn">from</span> <span class="nn">..util.typing</span> <span class="kn">import</span> <span class="n">Literal</span>
<span class="kn">from</span> <span class="nn">..util.typing</span> <span class="kn">import</span> <span class="n">Protocol</span>

<span class="k">if</span> <span class="n">typing</span><span class="o">.</span><span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">_EntityType</span>
    <span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">_IdentityKeyType</span>
    <span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">_InstanceDict</span>
    <span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">OrmExecuteOptionsParameter</span>
    <span class="kn">from</span> <span class="nn">.interfaces</span> <span class="kn">import</span> <span class="n">ORMOption</span>
    <span class="kn">from</span> <span class="nn">.interfaces</span> <span class="kn">import</span> <span class="n">UserDefinedOption</span>
    <span class="kn">from</span> <span class="nn">.mapper</span> <span class="kn">import</span> <span class="n">Mapper</span>
    <span class="kn">from</span> <span class="nn">.path_registry</span> <span class="kn">import</span> <span class="n">PathRegistry</span>
    <span class="kn">from</span> <span class="nn">.query</span> <span class="kn">import</span> <span class="n">RowReturningQuery</span>
    <span class="kn">from</span> <span class="nn">..engine</span> <span class="kn">import</span> <span class="n">CursorResult</span>
    <span class="kn">from</span> <span class="nn">..engine</span> <span class="kn">import</span> <span class="n">Result</span>
    <span class="kn">from</span> <span class="nn">..engine</span> <span class="kn">import</span> <span class="n">Row</span>
    <span class="kn">from</span> <span class="nn">..engine</span> <span class="kn">import</span> <span class="n">RowMapping</span>
    <span class="kn">from</span> <span class="nn">..engine.base</span> <span class="kn">import</span> <span class="n">Transaction</span>
    <span class="kn">from</span> <span class="nn">..engine.base</span> <span class="kn">import</span> <span class="n">TwoPhaseTransaction</span>
    <span class="kn">from</span> <span class="nn">..engine.interfaces</span> <span class="kn">import</span> <span class="n">_CoreAnyExecuteParams</span>
    <span class="kn">from</span> <span class="nn">..engine.interfaces</span> <span class="kn">import</span> <span class="n">_CoreSingleExecuteParams</span>
    <span class="kn">from</span> <span class="nn">..engine.interfaces</span> <span class="kn">import</span> <span class="n">_ExecuteOptions</span>
    <span class="kn">from</span> <span class="nn">..engine.interfaces</span> <span class="kn">import</span> <span class="n">CoreExecuteOptionsParameter</span>
    <span class="kn">from</span> <span class="nn">..engine.result</span> <span class="kn">import</span> <span class="n">ScalarResult</span>
    <span class="kn">from</span> <span class="nn">..event</span> <span class="kn">import</span> <span class="n">_InstanceLevelDispatch</span>
    <span class="kn">from</span> <span class="nn">..sql._typing</span> <span class="kn">import</span> <span class="n">_ColumnsClauseArgument</span>
    <span class="kn">from</span> <span class="nn">..sql._typing</span> <span class="kn">import</span> <span class="n">_InfoType</span>
    <span class="kn">from</span> <span class="nn">..sql._typing</span> <span class="kn">import</span> <span class="n">_T0</span>
    <span class="kn">from</span> <span class="nn">..sql._typing</span> <span class="kn">import</span> <span class="n">_T1</span>
    <span class="kn">from</span> <span class="nn">..sql._typing</span> <span class="kn">import</span> <span class="n">_T2</span>
    <span class="kn">from</span> <span class="nn">..sql._typing</span> <span class="kn">import</span> <span class="n">_T3</span>
    <span class="kn">from</span> <span class="nn">..sql._typing</span> <span class="kn">import</span> <span class="n">_T4</span>
    <span class="kn">from</span> <span class="nn">..sql._typing</span> <span class="kn">import</span> <span class="n">_T5</span>
    <span class="kn">from</span> <span class="nn">..sql._typing</span> <span class="kn">import</span> <span class="n">_T6</span>
    <span class="kn">from</span> <span class="nn">..sql._typing</span> <span class="kn">import</span> <span class="n">_T7</span>
    <span class="kn">from</span> <span class="nn">..sql._typing</span> <span class="kn">import</span> <span class="n">_TypedColumnClauseArgument</span> <span class="k">as</span> <span class="n">_TCCA</span>
    <span class="kn">from</span> <span class="nn">..sql.base</span> <span class="kn">import</span> <span class="n">Executable</span>
    <span class="kn">from</span> <span class="nn">..sql.base</span> <span class="kn">import</span> <span class="n">ExecutableOption</span>
    <span class="kn">from</span> <span class="nn">..sql.dml</span> <span class="kn">import</span> <span class="n">UpdateBase</span>
    <span class="kn">from</span> <span class="nn">..sql.elements</span> <span class="kn">import</span> <span class="n">ClauseElement</span>
    <span class="kn">from</span> <span class="nn">..sql.roles</span> <span class="kn">import</span> <span class="n">TypedColumnsClauseRole</span>
    <span class="kn">from</span> <span class="nn">..sql.selectable</span> <span class="kn">import</span> <span class="n">ForUpdateParameter</span>
    <span class="kn">from</span> <span class="nn">..sql.selectable</span> <span class="kn">import</span> <span class="n">TypedReturnsRows</span>

<span class="n">_T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_T&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="n">Any</span><span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Session&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SessionTransaction&quot;</span><span class="p">,</span>
    <span class="s2">&quot;sessionmaker&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ORMExecuteState&quot;</span><span class="p">,</span>
    <span class="s2">&quot;close_all_sessions&quot;</span><span class="p">,</span>
    <span class="s2">&quot;make_transient&quot;</span><span class="p">,</span>
    <span class="s2">&quot;make_transient_to_detached&quot;</span><span class="p">,</span>
    <span class="s2">&quot;object_session&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">_sessions</span><span class="p">:</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Session</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>
<span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Weak-referencing dictionary of :class:`.Session` objects.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">statelib</span><span class="o">.</span><span class="n">_sessions</span> <span class="o">=</span> <span class="n">_sessions</span>

<span class="n">_PKIdentityArgument</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span>

<span class="n">_BindArguments</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>

<span class="n">_EntityBindKey</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">_O</span><span class="p">],</span> <span class="s2">&quot;Mapper[_O]&quot;</span><span class="p">]</span>
<span class="n">_SessionBindKey</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="s2">&quot;Mapper[Any]&quot;</span><span class="p">,</span> <span class="s2">&quot;TableClause&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="n">_SessionBind</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="s2">&quot;Engine&quot;</span><span class="p">,</span> <span class="s2">&quot;Connection&quot;</span><span class="p">]</span>

<span class="n">JoinTransactionMode</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span>
    <span class="s2">&quot;conditional_savepoint&quot;</span><span class="p">,</span>
    <span class="s2">&quot;rollback_only&quot;</span><span class="p">,</span>
    <span class="s2">&quot;control_fully&quot;</span><span class="p">,</span>
    <span class="s2">&quot;create_savepoint&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="k">class</span> <span class="nc">_ConnectionCallableProto</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;a callable that returns a :class:`.Connection` given an instance.</span>

<span class="sd">    This callable, when present on a :class:`.Session`, is called only from the</span>
<span class="sd">    ORM&#39;s persistence mechanism (i.e. the unit of work flush process) to allow</span>
<span class="sd">    for connection-per-instance schemes (i.e. horizontal sharding) to be used</span>
<span class="sd">    as persistence time.</span>

<span class="sd">    This callable is not present on a plain :class:`.Session`, however</span>
<span class="sd">    is established when using the horizontal sharding extension.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapper</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">instance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Connection</span><span class="p">:</span> <span class="o">...</span>


<span class="k">def</span> <span class="nf">_state_session</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Session</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Given an :class:`.InstanceState`, return the :class:`.Session`</span>
<span class="sd">    associated, if any.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">state</span><span class="o">.</span><span class="n">session</span>


<span class="k">class</span> <span class="nc">_SessionClassMethods</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class-level methods for :class:`.Session`, :class:`.sessionmaker`.&quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@util</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span>
        <span class="s2">&quot;1.3&quot;</span><span class="p">,</span>
        <span class="s2">&quot;The :meth:`.Session.close_all` method is deprecated and will be &quot;</span>
        <span class="s2">&quot;removed in a future release.  Please refer to &quot;</span>
        <span class="s2">&quot;:func:`.session.close_all_sessions`.&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">close_all</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Close *all* sessions in memory.&quot;&quot;&quot;</span>

        <span class="n">close_all_sessions</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@util</span><span class="o">.</span><span class="n">preload_module</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.orm.util&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">identity_key</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">class_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ident</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">instance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">row</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Row</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">RowMapping</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">identity_token</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_IdentityKeyType</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an identity key.</span>

<span class="sd">        This is an alias of :func:`.util.identity_key`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">preloaded</span><span class="o">.</span><span class="n">orm_util</span><span class="o">.</span><span class="n">identity_key</span><span class="p">(</span>
            <span class="n">class_</span><span class="p">,</span>
            <span class="n">ident</span><span class="p">,</span>
            <span class="n">instance</span><span class="o">=</span><span class="n">instance</span><span class="p">,</span>
            <span class="n">row</span><span class="o">=</span><span class="n">row</span><span class="p">,</span>
            <span class="n">identity_token</span><span class="o">=</span><span class="n">identity_token</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">object_session</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Session</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the :class:`.Session` to which an object belongs.</span>

<span class="sd">        This is an alias of :func:`.object_session`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">object_session</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SessionTransactionState</span><span class="p">(</span><span class="n">_StateChangeState</span><span class="p">):</span>
    <span class="n">ACTIVE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">PREPARED</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">COMMITTED</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">DEACTIVE</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">CLOSED</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">PROVISIONING_CONNECTION</span> <span class="o">=</span> <span class="mi">6</span>


<span class="c1"># backwards compatibility</span>
<span class="n">ACTIVE</span><span class="p">,</span> <span class="n">PREPARED</span><span class="p">,</span> <span class="n">COMMITTED</span><span class="p">,</span> <span class="n">DEACTIVE</span><span class="p">,</span> <span class="n">CLOSED</span><span class="p">,</span> <span class="n">PROVISIONING_CONNECTION</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
    <span class="n">SessionTransactionState</span>
<span class="p">)</span>


<span class="k">class</span> <span class="nc">ORMExecuteState</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">MemoizedSlots</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a call to the :meth:`_orm.Session.execute` method, as passed</span>
<span class="sd">    to the :meth:`.SessionEvents.do_orm_execute` event hook.</span>

<span class="sd">    .. versionadded:: 1.4</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :ref:`session_execute_events` - top level documentation on how</span>
<span class="sd">        to use :meth:`_orm.SessionEvents.do_orm_execute`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;session&quot;</span><span class="p">,</span>
        <span class="s2">&quot;statement&quot;</span><span class="p">,</span>
        <span class="s2">&quot;parameters&quot;</span><span class="p">,</span>
        <span class="s2">&quot;execution_options&quot;</span><span class="p">,</span>
        <span class="s2">&quot;local_execution_options&quot;</span><span class="p">,</span>
        <span class="s2">&quot;bind_arguments&quot;</span><span class="p">,</span>
        <span class="s2">&quot;identity_token&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_compile_state_cls&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_starting_event_idx&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_events_todo&quot;</span><span class="p">,</span>
        <span class="s2">&quot;_update_execution_options&quot;</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">session</span><span class="p">:</span> <span class="n">Session</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The :class:`_orm.Session` in use.&quot;&quot;&quot;</span>

    <span class="n">statement</span><span class="p">:</span> <span class="n">Executable</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The SQL statement being invoked.</span>

<span class="sd">    For an ORM selection as would</span>
<span class="sd">    be retrieved from :class:`_orm.Query`, this is an instance of</span>
<span class="sd">    :class:`_sql.select` that was generated from the ORM query.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">parameters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dictionary of parameters that was passed to</span>
<span class="sd">    :meth:`_orm.Session.execute`.&quot;&quot;&quot;</span>

    <span class="n">execution_options</span><span class="p">:</span> <span class="n">_ExecuteOptions</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The complete dictionary of current execution options.</span>

<span class="sd">    This is a merge of the statement level options with the</span>
<span class="sd">    locally passed execution options.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :attr:`_orm.ORMExecuteState.local_execution_options`</span>

<span class="sd">        :meth:`_sql.Executable.execution_options`</span>

<span class="sd">        :ref:`orm_queryguide_execution_options`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">local_execution_options</span><span class="p">:</span> <span class="n">_ExecuteOptions</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Dictionary view of the execution options passed to the</span>
<span class="sd">    :meth:`.Session.execute` method.</span>

<span class="sd">    This does not include options that may be associated with the statement</span>
<span class="sd">    being invoked.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :attr:`_orm.ORMExecuteState.execution_options`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">_BindArguments</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The dictionary passed as the</span>
<span class="sd">    :paramref:`_orm.Session.execute.bind_arguments` dictionary.</span>

<span class="sd">    This dictionary may be used by extensions to :class:`_orm.Session` to pass</span>
<span class="sd">    arguments that will assist in determining amongst a set of database</span>
<span class="sd">    connections which one should be used to invoke this statement.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_compile_state_cls</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">ORMCompileState</span><span class="p">]]</span>
    <span class="n">_starting_event_idx</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">_events_todo</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>
    <span class="n">_update_execution_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_ExecuteOptions</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">session</span><span class="p">:</span> <span class="n">Session</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">Executable</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">],</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">_ExecuteOptions</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">_BindArguments</span><span class="p">,</span>
        <span class="n">compile_state_cls</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">ORMCompileState</span><span class="p">]],</span>
        <span class="n">events_todo</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">_InstanceLevelDispatch</span><span class="p">[</span><span class="n">Session</span><span class="p">]],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct a new :class:`_orm.ORMExecuteState`.</span>

<span class="sd">        this object is constructed internally.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statement</span> <span class="o">=</span> <span class="n">statement</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span> <span class="o">=</span> <span class="n">parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_execution_options</span> <span class="o">=</span> <span class="n">execution_options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execution_options</span> <span class="o">=</span> <span class="n">statement</span><span class="o">.</span><span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="n">execution_options</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bind_arguments</span> <span class="o">=</span> <span class="n">bind_arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_compile_state_cls</span> <span class="o">=</span> <span class="n">compile_state_cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_events_todo</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">events_todo</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remaining_events</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">_InstanceLevelDispatch</span><span class="p">[</span><span class="n">Session</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_events_todo</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_starting_event_idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>

    <span class="k">def</span> <span class="nf">invoke_statement</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Executable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">OrmExecuteOptionsParameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute the statement represented by this</span>
<span class="sd">        :class:`.ORMExecuteState`, without re-invoking events that have</span>
<span class="sd">        already proceeded.</span>

<span class="sd">        This method essentially performs a re-entrant execution of the current</span>
<span class="sd">        statement for which the :meth:`.SessionEvents.do_orm_execute` event is</span>
<span class="sd">        being currently invoked.    The use case for this is for event handlers</span>
<span class="sd">        that want to override how the ultimate</span>
<span class="sd">        :class:`_engine.Result` object is returned, such as for schemes that</span>
<span class="sd">        retrieve results from an offline cache or which concatenate results</span>
<span class="sd">        from multiple executions.</span>

<span class="sd">        When the :class:`_engine.Result` object is returned by the actual</span>
<span class="sd">        handler function within :meth:`_orm.SessionEvents.do_orm_execute` and</span>
<span class="sd">        is propagated to the calling</span>
<span class="sd">        :meth:`_orm.Session.execute` method, the remainder of the</span>
<span class="sd">        :meth:`_orm.Session.execute` method is preempted and the</span>
<span class="sd">        :class:`_engine.Result` object is returned to the caller of</span>
<span class="sd">        :meth:`_orm.Session.execute` immediately.</span>

<span class="sd">        :param statement: optional statement to be invoked, in place of the</span>
<span class="sd">         statement currently represented by :attr:`.ORMExecuteState.statement`.</span>

<span class="sd">        :param params: optional dictionary of parameters or list of parameters</span>
<span class="sd">         which will be merged into the existing</span>
<span class="sd">         :attr:`.ORMExecuteState.parameters` of this :class:`.ORMExecuteState`.</span>

<span class="sd">         .. versionchanged:: 2.0 a list of parameter dictionaries is accepted</span>
<span class="sd">            for executemany executions.</span>

<span class="sd">        :param execution_options: optional dictionary of execution options</span>
<span class="sd">         will be merged into the existing</span>
<span class="sd">         :attr:`.ORMExecuteState.execution_options` of this</span>
<span class="sd">         :class:`.ORMExecuteState`.</span>

<span class="sd">        :param bind_arguments: optional dictionary of bind_arguments</span>
<span class="sd">         which will be merged amongst the current</span>
<span class="sd">         :attr:`.ORMExecuteState.bind_arguments`</span>
<span class="sd">         of this :class:`.ORMExecuteState`.</span>

<span class="sd">        :return: a :class:`_engine.Result` object with ORM-level results.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`do_orm_execute_re_executing` - background and examples on the</span>
<span class="sd">            appropriate usage of :meth:`_orm.ORMExecuteState.invoke_statement`.</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">statement</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">statement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span>

        <span class="n">_bind_arguments</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bind_arguments</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bind_arguments</span><span class="p">:</span>
            <span class="n">_bind_arguments</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">bind_arguments</span><span class="p">)</span>
        <span class="n">_bind_arguments</span><span class="p">[</span><span class="s2">&quot;_sa_skip_events&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">params</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_executemany</span><span class="p">:</span>
                <span class="n">_params</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">exec_many_parameters</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
                    <span class="s2">&quot;List[Dict[str, Any]]&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">_existing_params</span><span class="p">,</span> <span class="n">_new_params</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">zip_longest</span><span class="p">(</span>
                    <span class="n">exec_many_parameters</span><span class="p">,</span>
                    <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;List[Dict[str, Any]]&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">),</span>
                <span class="p">):</span>
                    <span class="k">if</span> <span class="n">_existing_params</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">_new_params</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Can&#39;t apply executemany parameters to &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;statement; number of parameter sets passed to &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;Session.execute() (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">exec_many_parameters</span><span class="p">)</span><span class="si">}</span><span class="s2">) &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;does not match number of parameter sets given &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;to ORMExecuteState.invoke_statement() &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                        <span class="p">)</span>
                    <span class="n">_existing_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_existing_params</span><span class="p">)</span>
                    <span class="n">_existing_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_new_params</span><span class="p">)</span>
                    <span class="n">_params</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_existing_params</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_params</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;Dict[str, Any]&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">))</span>
                <span class="n">_params</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;Dict[str, Any]&quot;</span><span class="p">,</span> <span class="n">params</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_params</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span>

        <span class="n">_execution_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_execution_options</span>
        <span class="k">if</span> <span class="n">execution_options</span><span class="p">:</span>
            <span class="n">_execution_options</span> <span class="o">=</span> <span class="n">_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">execution_options</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_execute_internal</span><span class="p">(</span>
            <span class="n">statement</span><span class="p">,</span>
            <span class="n">_params</span><span class="p">,</span>
            <span class="n">execution_options</span><span class="o">=</span><span class="n">_execution_options</span><span class="p">,</span>
            <span class="n">bind_arguments</span><span class="o">=</span><span class="n">_bind_arguments</span><span class="p">,</span>
            <span class="n">_parent_execute_state</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bind_mapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapper</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the :class:`_orm.Mapper` that is the primary &quot;bind&quot; mapper.</span>

<span class="sd">        For an :class:`_orm.ORMExecuteState` object invoking an ORM</span>
<span class="sd">        statement, that is, the :attr:`_orm.ORMExecuteState.is_orm_statement`</span>
<span class="sd">        attribute is ``True``, this attribute will return the</span>
<span class="sd">        :class:`_orm.Mapper` that is considered to be the &quot;primary&quot; mapper</span>
<span class="sd">        of the statement.   The term &quot;bind mapper&quot; refers to the fact that</span>
<span class="sd">        a :class:`_orm.Session` object may be &quot;bound&quot; to multiple</span>
<span class="sd">        :class:`_engine.Engine` objects keyed to mapped classes, and the</span>
<span class="sd">        &quot;bind mapper&quot; determines which of those :class:`_engine.Engine` objects</span>
<span class="sd">        would be selected.</span>

<span class="sd">        For a statement that is invoked against a single mapped class,</span>
<span class="sd">        :attr:`_orm.ORMExecuteState.bind_mapper` is intended to be a reliable</span>
<span class="sd">        way of getting this mapper.</span>

<span class="sd">        .. versionadded:: 1.4.0b2</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :attr:`_orm.ORMExecuteState.all_mappers`</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mp</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapper</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind_arguments</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;mapper&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mp</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">all_mappers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Mapper</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a sequence of all :class:`_orm.Mapper` objects that are</span>
<span class="sd">        involved at the top level of this statement.</span>

<span class="sd">        By &quot;top level&quot; we mean those :class:`_orm.Mapper` objects that would</span>
<span class="sd">        be represented in the result set rows for a :func:`_sql.select`</span>
<span class="sd">        query, or for a :func:`_dml.update` or :func:`_dml.delete` query,</span>
<span class="sd">        the mapper that is the main subject of the UPDATE or DELETE.</span>

<span class="sd">        .. versionadded:: 1.4.0b2</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :attr:`_orm.ORMExecuteState.bind_mapper`</span>



<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_orm_statement</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="p">,</span> <span class="p">(</span><span class="n">Select</span><span class="p">,</span> <span class="n">FromStatement</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">column_descriptions</span><span class="p">:</span>
                <span class="n">ent</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;entity&quot;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ent</span><span class="p">:</span>
                    <span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">ent</span><span class="p">,</span> <span class="n">raiseerr</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">insp</span> <span class="ow">and</span> <span class="n">insp</span><span class="o">.</span><span class="n">mapper</span> <span class="ow">and</span> <span class="n">insp</span><span class="o">.</span><span class="n">mapper</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                        <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">insp</span><span class="o">.</span><span class="n">mapper</span><span class="p">)</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">insp</span><span class="o">.</span><span class="n">mapper</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">is_dml</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind_mapper</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">bind_mapper</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_orm_statement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return True if the operation is an ORM statement.</span>

<span class="sd">        This indicates that the select(), insert(), update(), or delete()</span>
<span class="sd">        being invoked contains ORM entities as subjects.   For a statement</span>
<span class="sd">        that does not have ORM entities and instead refers only to</span>
<span class="sd">        :class:`.Table` metadata, it is invoked as a Core SQL statement</span>
<span class="sd">        and no ORM-level automation takes place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_state_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_executemany</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return True if the parameters are a multi-element list of</span>
<span class="sd">        dictionaries with more than one dictionary.</span>

<span class="sd">        .. versionadded:: 2.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_select</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return True if this is a SELECT operation.</span>

<span class="sd">        .. versionchanged:: 2.0.30 - the attribute is also True for a</span>
<span class="sd">           :meth:`_sql.Select.from_statement` construct that is itself against</span>
<span class="sd">           a :class:`_sql.Select` construct, such as</span>
<span class="sd">           ``select(Entity).from_statement(select(..))``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">is_select</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_from_statement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return True if this operation is a</span>
<span class="sd">        :meth:`_sql.Select.from_statement` operation.</span>

<span class="sd">        This is independent from :attr:`_orm.ORMExecuteState.is_select`, as a</span>
<span class="sd">        ``select().from_statement()`` construct can be used with</span>
<span class="sd">        INSERT/UPDATE/DELETE RETURNING types of statements as well.</span>
<span class="sd">        :attr:`_orm.ORMExecuteState.is_select` will only be set if the</span>
<span class="sd">        :meth:`_sql.Select.from_statement` is itself against a</span>
<span class="sd">        :class:`_sql.Select` construct.</span>

<span class="sd">        .. versionadded:: 2.0.30</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">is_from_statement</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_insert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return True if this is an INSERT operation.</span>

<span class="sd">        .. versionchanged:: 2.0.30 - the attribute is also True for a</span>
<span class="sd">           :meth:`_sql.Select.from_statement` construct that is itself against</span>
<span class="sd">           a :class:`_sql.Insert` construct, such as</span>
<span class="sd">           ``select(Entity).from_statement(insert(..))``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">is_dml</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">is_insert</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_update</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return True if this is an UPDATE operation.</span>

<span class="sd">        .. versionchanged:: 2.0.30 - the attribute is also True for a</span>
<span class="sd">           :meth:`_sql.Select.from_statement` construct that is itself against</span>
<span class="sd">           a :class:`_sql.Update` construct, such as</span>
<span class="sd">           ``select(Entity).from_statement(update(..))``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">is_dml</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">is_update</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_delete</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return True if this is a DELETE operation.</span>

<span class="sd">        .. versionchanged:: 2.0.30 - the attribute is also True for a</span>
<span class="sd">           :meth:`_sql.Select.from_statement` construct that is itself against</span>
<span class="sd">           a :class:`_sql.Delete` construct, such as</span>
<span class="sd">           ``select(Entity).from_statement(delete(..))``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">is_dml</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">is_delete</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_crud</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="p">,</span> <span class="p">(</span><span class="n">dml</span><span class="o">.</span><span class="n">Update</span><span class="p">,</span> <span class="n">dml</span><span class="o">.</span><span class="n">Delete</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">update_execution_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the local execution options with new values.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_execution_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_execution_options</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_orm_compile_options</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span>
            <span class="n">context</span><span class="o">.</span><span class="n">ORMCompileState</span><span class="o">.</span><span class="n">default_compile_options</span><span class="p">,</span>
            <span class="n">Type</span><span class="p">[</span><span class="n">context</span><span class="o">.</span><span class="n">ORMCompileState</span><span class="o">.</span><span class="n">default_compile_options</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_select</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">_compile_options</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">opts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">opts</span><span class="o">.</span><span class="n">isinstance</span><span class="p">(</span>
            <span class="n">context</span><span class="o">.</span><span class="n">ORMCompileState</span><span class="o">.</span><span class="n">default_compile_options</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">opts</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lazy_loaded_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An :class:`.InstanceState` that is using this statement execution</span>
<span class="sd">        for a lazy load operation.</span>

<span class="sd">        The primary rationale for this attribute is to support the horizontal</span>
<span class="sd">        sharding extension, where it is available within specific query</span>
<span class="sd">        execution time hooks created by this extension.   To that end, the</span>
<span class="sd">        attribute is only intended to be meaningful at **query execution</span>
<span class="sd">        time**, and importantly not any time prior to that, including query</span>
<span class="sd">        compilation time.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">load_options</span><span class="o">.</span><span class="n">_lazy_loaded_from</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">loader_strategy_path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">PathRegistry</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the :class:`.PathRegistry` for the current load path.</span>

<span class="sd">        This object represents the &quot;path&quot; in a query along relationships</span>
<span class="sd">        when a particular object or collection is being loaded.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orm_compile_options</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">opts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">opts</span><span class="o">.</span><span class="n">_current_path</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_column_load</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if the operation is refreshing column-oriented</span>
<span class="sd">        attributes on an existing ORM object.</span>

<span class="sd">        This occurs during operations such as :meth:`_orm.Session.refresh`,</span>
<span class="sd">        as well as when an attribute deferred by :func:`_orm.defer` is</span>
<span class="sd">        being loaded, or an attribute that was expired either directly</span>
<span class="sd">        by :meth:`_orm.Session.expire` or via a commit operation is being</span>
<span class="sd">        loaded.</span>

<span class="sd">        Handlers will very likely not want to add any options to queries</span>
<span class="sd">        when such an operation is occurring as the query should be a straight</span>
<span class="sd">        primary key fetch which should not have any additional WHERE criteria,</span>
<span class="sd">        and loader options travelling with the instance</span>
<span class="sd">        will have already been added to the query.</span>

<span class="sd">        .. versionadded:: 1.4.0b2</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :attr:`_orm.ORMExecuteState.is_relationship_load`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orm_compile_options</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">opts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">opts</span><span class="o">.</span><span class="n">_for_refresh_state</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_relationship_load</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if this load is loading objects on behalf of a</span>
<span class="sd">        relationship.</span>

<span class="sd">        This means, the loader in effect is either a LazyLoader,</span>
<span class="sd">        SelectInLoader, SubqueryLoader, or similar, and the entire</span>
<span class="sd">        SELECT statement being emitted is on behalf of a relationship</span>
<span class="sd">        load.</span>

<span class="sd">        Handlers will very likely not want to add any options to queries</span>
<span class="sd">        when such an operation is occurring, as loader options are already</span>
<span class="sd">        capable of being propagated to relationship loaders and should</span>
<span class="sd">        be already present.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :attr:`_orm.ORMExecuteState.is_column_load`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">opts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orm_compile_options</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loader_strategy_path</span>
        <span class="k">return</span> <span class="n">path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">path</span><span class="o">.</span><span class="n">is_root</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">load_options</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">context</span><span class="o">.</span><span class="n">QueryContext</span><span class="o">.</span><span class="n">default_load_options</span><span class="p">,</span>
        <span class="n">Type</span><span class="p">[</span><span class="n">context</span><span class="o">.</span><span class="n">QueryContext</span><span class="o">.</span><span class="n">default_load_options</span><span class="p">],</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the load_options that will be used for this execution.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_select</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;This ORM execution is not against a SELECT statement &quot;</span>
                <span class="s2">&quot;so there are no load options.&quot;</span>
            <span class="p">)</span>

        <span class="n">lo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">context</span><span class="o">.</span><span class="n">QueryContext</span><span class="o">.</span><span class="n">default_load_options</span><span class="p">,</span>
            <span class="n">Type</span><span class="p">[</span><span class="n">context</span><span class="o">.</span><span class="n">QueryContext</span><span class="o">.</span><span class="n">default_load_options</span><span class="p">],</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execution_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;_sa_orm_load_options&quot;</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">QueryContext</span><span class="o">.</span><span class="n">default_load_options</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">lo</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">update_delete_options</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">bulk_persistence</span><span class="o">.</span><span class="n">BulkUDCompileState</span><span class="o">.</span><span class="n">default_update_options</span><span class="p">,</span>
        <span class="n">Type</span><span class="p">[</span><span class="n">bulk_persistence</span><span class="o">.</span><span class="n">BulkUDCompileState</span><span class="o">.</span><span class="n">default_update_options</span><span class="p">],</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the update_delete_options that will be used for this</span>
<span class="sd">        execution.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_crud</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;This ORM execution is not against an UPDATE or DELETE &quot;</span>
                <span class="s2">&quot;statement so there are no update options.&quot;</span>
            <span class="p">)</span>
        <span class="n">uo</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">bulk_persistence</span><span class="o">.</span><span class="n">BulkUDCompileState</span><span class="o">.</span><span class="n">default_update_options</span><span class="p">,</span>
            <span class="n">Type</span><span class="p">[</span><span class="n">bulk_persistence</span><span class="o">.</span><span class="n">BulkUDCompileState</span><span class="o">.</span><span class="n">default_update_options</span><span class="p">],</span>
        <span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execution_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="s2">&quot;_sa_orm_update_options&quot;</span><span class="p">,</span>
            <span class="n">bulk_persistence</span><span class="o">.</span><span class="n">BulkUDCompileState</span><span class="o">.</span><span class="n">default_update_options</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">uo</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_non_compile_orm_options</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ORMOption</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">opt</span>
            <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">_with_options</span>
            <span class="k">if</span> <span class="n">is_orm_option</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">opt</span><span class="o">.</span><span class="n">_is_compile_state</span>
        <span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">user_defined_options</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">UserDefinedOption</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The sequence of :class:`.UserDefinedOptions` that have been</span>
<span class="sd">        associated with the statement being invoked.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">opt</span>
            <span class="k">for</span> <span class="n">opt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">statement</span><span class="o">.</span><span class="n">_with_options</span>
            <span class="k">if</span> <span class="n">is_user_defined_option</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span>
        <span class="p">]</span>


<span class="k">class</span> <span class="nc">SessionTransactionOrigin</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;indicates the origin of a :class:`.SessionTransaction`.</span>

<span class="sd">    This enumeration is present on the</span>
<span class="sd">    :attr:`.SessionTransaction.origin` attribute of any</span>
<span class="sd">    :class:`.SessionTransaction` object.</span>

<span class="sd">    .. versionadded:: 2.0</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">AUTOBEGIN</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;transaction were started by autobegin&quot;&quot;&quot;</span>

    <span class="n">BEGIN</span> <span class="o">=</span> <span class="mi">1</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;transaction were started by calling :meth:`_orm.Session.begin`&quot;&quot;&quot;</span>

    <span class="n">BEGIN_NESTED</span> <span class="o">=</span> <span class="mi">2</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;tranaction were started by :meth:`_orm.Session.begin_nested`&quot;&quot;&quot;</span>

    <span class="n">SUBTRANSACTION</span> <span class="o">=</span> <span class="mi">3</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;transaction is an internal &quot;subtransaction&quot; &quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">SessionTransaction</span><span class="p">(</span><span class="n">_StateChange</span><span class="p">,</span> <span class="n">TransactionalContext</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A :class:`.Session`-level transaction.</span>

<span class="sd">    :class:`.SessionTransaction` is produced from the</span>
<span class="sd">    :meth:`_orm.Session.begin`</span>
<span class="sd">    and :meth:`_orm.Session.begin_nested` methods.   It&#39;s largely an internal</span>
<span class="sd">    object that in modern use provides a context manager for session</span>
<span class="sd">    transactions.</span>

<span class="sd">    Documentation on interacting with :class:`_orm.SessionTransaction` is</span>
<span class="sd">    at: :ref:`unitofwork_transaction`.</span>


<span class="sd">    .. versionchanged:: 1.4  The scoping and API methods to work with the</span>
<span class="sd">       :class:`_orm.SessionTransaction` object directly have been simplified.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :ref:`unitofwork_transaction`</span>

<span class="sd">        :meth:`.Session.begin`</span>

<span class="sd">        :meth:`.Session.begin_nested`</span>

<span class="sd">        :meth:`.Session.rollback`</span>

<span class="sd">        :meth:`.Session.commit`</span>

<span class="sd">        :meth:`.Session.in_transaction`</span>

<span class="sd">        :meth:`.Session.in_nested_transaction`</span>

<span class="sd">        :meth:`.Session.get_transaction`</span>

<span class="sd">        :meth:`.Session.get_nested_transaction`</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_rollback_exception</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="ne">BaseException</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">_connections</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span><span class="n">Engine</span><span class="p">,</span> <span class="n">Connection</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Connection</span><span class="p">,</span> <span class="n">Transaction</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span>
    <span class="p">]</span>
    <span class="n">session</span><span class="p">:</span> <span class="n">Session</span>
    <span class="n">_parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SessionTransaction</span><span class="p">]</span>

    <span class="n">_state</span><span class="p">:</span> <span class="n">SessionTransactionState</span>

    <span class="n">_new</span><span class="p">:</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">object</span><span class="p">]</span>
    <span class="n">_deleted</span><span class="p">:</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">object</span><span class="p">]</span>
    <span class="n">_dirty</span><span class="p">:</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">object</span><span class="p">]</span>
    <span class="n">_key_switches</span><span class="p">:</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">[</span>
        <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="p">]</span>

    <span class="n">origin</span><span class="p">:</span> <span class="n">SessionTransactionOrigin</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Origin of this :class:`_orm.SessionTransaction`.</span>

<span class="sd">    Refers to a :class:`.SessionTransactionOrigin` instance which is an</span>
<span class="sd">    enumeration indicating the source event that led to constructing</span>
<span class="sd">    this :class:`_orm.SessionTransaction`.</span>

<span class="sd">    .. versionadded:: 2.0</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indicates if this is a nested, or SAVEPOINT, transaction.</span>

<span class="sd">    When :attr:`.SessionTransaction.nested` is True, it is expected</span>
<span class="sd">    that :attr:`.SessionTransaction.parent` will be present as well,</span>
<span class="sd">    linking to the enclosing :class:`.SessionTransaction`.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :attr:`.SessionTransaction.origin`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">session</span><span class="p">:</span> <span class="n">Session</span><span class="p">,</span>
        <span class="n">origin</span><span class="p">:</span> <span class="n">SessionTransactionOrigin</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SessionTransaction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">TransactionalContext</span><span class="o">.</span><span class="n">_trans_ctx_check</span><span class="p">(</span><span class="n">session</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nested</span> <span class="o">=</span> <span class="n">nested</span> <span class="o">=</span> <span class="n">origin</span> <span class="ow">is</span> <span class="n">SessionTransactionOrigin</span><span class="o">.</span><span class="n">BEGIN_NESTED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>

        <span class="k">if</span> <span class="n">session</span><span class="o">.</span><span class="n">_close_state</span> <span class="ow">is</span> <span class="n">_SessionCloseState</span><span class="o">.</span><span class="n">CLOSED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;This Session has been permanently closed and is unable &quot;</span>
                <span class="s2">&quot;to handle any more transaction requests.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">nested</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">parent</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;Can&#39;t start a SAVEPOINT transaction when no existing &quot;</span>
                    <span class="s2">&quot;transaction is in progress&quot;</span>
                <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_previous_nested_transaction</span> <span class="o">=</span> <span class="n">session</span><span class="o">.</span><span class="n">_nested_transaction</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="ow">is</span> <span class="n">SessionTransactionOrigin</span><span class="o">.</span><span class="n">SUBTRANSACTION</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">ACTIVE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_take_snapshot</span><span class="p">()</span>

        <span class="c1"># make sure transaction is assigned before we call the</span>
        <span class="c1"># dispatch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_transaction</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_transaction_create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_raise_for_prerequisite_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">operation_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">_StateChangeState</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NoReturn</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">DEACTIVE</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rollback_exception</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">PendingRollbackError</span><span class="p">(</span>
                    <span class="s2">&quot;This Session&#39;s transaction has been rolled back &quot;</span>
                    <span class="s2">&quot;due to a previous exception during flush.&quot;</span>
                    <span class="s2">&quot; To begin a new transaction with this Session, &quot;</span>
                    <span class="s2">&quot;first issue Session.rollback().&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot; Original exception was: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_rollback_exception</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">code</span><span class="o">=</span><span class="s2">&quot;7s2a&quot;</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;This session is in &#39;inactive&#39; state, due to the &quot;</span>
                    <span class="s2">&quot;SQL transaction being rolled back; no further SQL &quot;</span>
                    <span class="s2">&quot;can be emitted within this transaction.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">state</span> <span class="ow">is</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">CLOSED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ResourceClosedError</span><span class="p">(</span><span class="s2">&quot;This transaction is closed&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">state</span> <span class="ow">is</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">PROVISIONING_CONNECTION</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;This session is provisioning a new connection; concurrent &quot;</span>
                <span class="s2">&quot;operations are not permitted&quot;</span><span class="p">,</span>
                <span class="n">code</span><span class="o">=</span><span class="s2">&quot;isce&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;This session is in &#39;</span><span class="si">{</span><span class="n">state</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="si">}</span><span class="s2">&#39; state; no &quot;</span>
                <span class="s2">&quot;further SQL can be emitted within this transaction.&quot;</span>
            <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SessionTransaction</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The parent :class:`.SessionTransaction` of this</span>
<span class="sd">        :class:`.SessionTransaction`.</span>

<span class="sd">        If this attribute is ``None``, indicates this</span>
<span class="sd">        :class:`.SessionTransaction` is at the top of the stack, and</span>
<span class="sd">        corresponds to a real &quot;COMMIT&quot;/&quot;ROLLBACK&quot;</span>
<span class="sd">        block.  If non-``None``, then this is either a &quot;subtransaction&quot;</span>
<span class="sd">        (an internal marker object used by the flush process) or a</span>
<span class="sd">        &quot;nested&quot; / SAVEPOINT transaction.  If the</span>
<span class="sd">        :attr:`.SessionTransaction.nested` attribute is ``True``, then</span>
<span class="sd">        this is a SAVEPOINT, and if ``False``, indicates this a subtransaction.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_active</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">ACTIVE</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_transaction_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="nd">@_StateChange</span><span class="o">.</span><span class="n">declare_states</span><span class="p">(</span>
        <span class="p">(</span><span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">,),</span> <span class="n">_StateChangeStates</span><span class="o">.</span><span class="n">NO_CHANGE</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">connection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bindkey</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapper</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_ExecuteOptions</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Connection</span><span class="p">:</span>
        <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get_bind</span><span class="p">(</span><span class="n">bindkey</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">execution_options</span><span class="p">)</span>

    <span class="nd">@_StateChange</span><span class="o">.</span><span class="n">declare_states</span><span class="p">(</span>
        <span class="p">(</span><span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">,),</span> <span class="n">_StateChangeStates</span><span class="o">.</span><span class="n">NO_CHANGE</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">_begin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SessionTransaction</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">SessionTransaction</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span>
            <span class="p">(</span>
                <span class="n">SessionTransactionOrigin</span><span class="o">.</span><span class="n">BEGIN_NESTED</span>
                <span class="k">if</span> <span class="n">nested</span>
                <span class="k">else</span> <span class="n">SessionTransactionOrigin</span><span class="o">.</span><span class="n">SUBTRANSACTION</span>
            <span class="p">),</span>
            <span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iterate_self_and_parents</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">upto</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SessionTransaction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">SessionTransaction</span><span class="p">]:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">result</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">SessionTransaction</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">current</span><span class="p">,)</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="n">upto</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;Transaction </span><span class="si">%s</span><span class="s2"> is not on the active transaction list&quot;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="n">upto</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_take_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transaction_boundary</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
            <span class="k">assert</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_new</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_deleted</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_dirty</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">_key_switches</span>
            <span class="k">return</span>

        <span class="n">is_begin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">SessionTransactionOrigin</span><span class="o">.</span><span class="n">BEGIN</span><span class="p">,</span>
            <span class="n">SessionTransactionOrigin</span><span class="o">.</span><span class="n">AUTOBEGIN</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_begin</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_restore_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirty_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Restore the restoration state taken before a transaction began.</span>

<span class="sd">        Corresponds to a rollback.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transaction_boundary</span>

        <span class="n">to_expunge</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_expunge_states</span><span class="p">(</span><span class="n">to_expunge</span><span class="p">,</span> <span class="n">to_transient</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">oldkey</span><span class="p">,</span> <span class="n">newkey</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># we probably can do this conditionally based on</span>
            <span class="c1"># if we expunged or not, but safe_discard does that anyway</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="c1"># restore the old key</span>
            <span class="n">s</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">oldkey</span>

            <span class="c1"># now restore the object, but only if we didn&#39;t expunge</span>
            <span class="k">if</span> <span class="n">s</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">to_expunge</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_deleted</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_update_impl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">revert_deletion</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dirty_only</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">modified</span> <span class="ow">or</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove the restoration state taken before a transaction began.</span>

<span class="sd">        Corresponds to a commit.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transaction_boundary</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">expire_on_commit</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">():</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>

            <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_detach_states</span><span class="p">(</span>
                <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
            <span class="k">assert</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">_dirty</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">)</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">_key_switches</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">)</span>

    <span class="nd">@_StateChange</span><span class="o">.</span><span class="n">declare_states</span><span class="p">(</span>
        <span class="p">(</span><span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">,),</span> <span class="n">_StateChangeStates</span><span class="o">.</span><span class="n">NO_CHANGE</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">_connection_for_bind</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bind</span><span class="p">:</span> <span class="n">_SessionBind</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CoreExecuteOptionsParameter</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Connection</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">execution_options</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Connection is already established for the &quot;</span>
                    <span class="s2">&quot;given bind; execution_options ignored&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">[</span><span class="n">bind</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">PROVISIONING_CONNECTION</span>

        <span class="n">local_connect</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">should_commit</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span>
                    <span class="n">bind</span><span class="p">,</span> <span class="n">execution_options</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">conn</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">engine</span><span class="o">.</span><span class="n">Connection</span><span class="p">):</span>
                    <span class="n">conn</span> <span class="o">=</span> <span class="n">bind</span>
                    <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">engine</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                            <span class="s2">&quot;Session already has a Connection associated &quot;</span>
                            <span class="s2">&quot;for the given Connection&#39;s Engine&quot;</span>
                        <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">conn</span> <span class="o">=</span> <span class="n">bind</span><span class="o">.</span><span class="n">connect</span><span class="p">()</span>
                    <span class="n">local_connect</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">execution_options</span><span class="p">:</span>
                    <span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="o">**</span><span class="n">execution_options</span><span class="p">)</span>

                <span class="n">transaction</span><span class="p">:</span> <span class="n">Transaction</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">twophase</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># TODO: shouldn&#39;t we only be here if not</span>
                    <span class="c1"># conn.in_transaction() ?</span>
                    <span class="c1"># if twophase is set and conn.in_transaction(), validate</span>
                    <span class="c1"># that it is in fact twophase.</span>
                    <span class="n">transaction</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin_twophase</span><span class="p">()</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
                    <span class="n">transaction</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin_nested</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">conn</span><span class="o">.</span><span class="n">in_transaction</span><span class="p">():</span>
                    <span class="n">join_transaction_mode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">join_transaction_mode</span>

                    <span class="k">if</span> <span class="n">join_transaction_mode</span> <span class="o">==</span> <span class="s2">&quot;conditional_savepoint&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">in_nested_transaction</span><span class="p">():</span>
                            <span class="n">join_transaction_mode</span> <span class="o">=</span> <span class="s2">&quot;create_savepoint&quot;</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">join_transaction_mode</span> <span class="o">=</span> <span class="s2">&quot;rollback_only&quot;</span>

                    <span class="k">if</span> <span class="n">join_transaction_mode</span> <span class="ow">in</span> <span class="p">(</span>
                        <span class="s2">&quot;control_fully&quot;</span><span class="p">,</span>
                        <span class="s2">&quot;rollback_only&quot;</span><span class="p">,</span>
                    <span class="p">):</span>
                        <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">in_nested_transaction</span><span class="p">():</span>
                            <span class="n">transaction</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">conn</span><span class="o">.</span><span class="n">_get_required_nested_transaction</span><span class="p">()</span>
                            <span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">transaction</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">_get_required_transaction</span><span class="p">()</span>
                        <span class="k">if</span> <span class="n">join_transaction_mode</span> <span class="o">==</span> <span class="s2">&quot;rollback_only&quot;</span><span class="p">:</span>
                            <span class="n">should_commit</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">elif</span> <span class="n">join_transaction_mode</span> <span class="o">==</span> <span class="s2">&quot;create_savepoint&quot;</span><span class="p">:</span>
                        <span class="n">transaction</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin_nested</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="n">join_transaction_mode</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">transaction</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># connection will not not be associated with this Session;</span>
                <span class="c1"># close it immediately so that it isn&#39;t closed under GC</span>
                <span class="k">if</span> <span class="n">local_connect</span><span class="p">:</span>
                    <span class="n">conn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bind_is_connection</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">engine</span><span class="o">.</span><span class="n">Connection</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">[</span><span class="n">conn</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">[</span><span class="n">conn</span><span class="o">.</span><span class="n">engine</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">conn</span><span class="p">,</span>
                    <span class="n">transaction</span><span class="p">,</span>
                    <span class="n">should_commit</span><span class="p">,</span>
                    <span class="ow">not</span> <span class="n">bind_is_connection</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_begin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">conn</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">ACTIVE</span>

    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">twophase</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;twophase&#39; mode not enabled, or not root transaction; &quot;</span>
                <span class="s2">&quot;can&#39;t prepare.&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_impl</span><span class="p">()</span>

    <span class="nd">@_StateChange</span><span class="o">.</span><span class="n">declare_states</span><span class="p">(</span>
        <span class="p">(</span><span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">,),</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">PREPARED</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">_prepare_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_commit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>

        <span class="n">stx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_transaction</span>
        <span class="k">assert</span> <span class="n">stx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">stx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subtransaction</span> <span class="ow">in</span> <span class="n">stx</span><span class="o">.</span><span class="n">_iterate_self_and_parents</span><span class="p">(</span><span class="n">upto</span><span class="o">=</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">subtransaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_flush_guard</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_is_clean</span><span class="p">():</span>
                    <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">FlushError</span><span class="p">(</span>
                    <span class="s2">&quot;Over 100 subsequent flushes have occurred within &quot;</span>
                    <span class="s2">&quot;session.commit() - is an after_flush() hook &quot;</span>
                    <span class="s2">&quot;creating new objects?&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">twophase</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="n">cast</span><span class="p">(</span><span class="s2">&quot;TwoPhaseTransaction&quot;</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">PREPARED</span>

    <span class="nd">@_StateChange</span><span class="o">.</span><span class="n">declare_states</span><span class="p">(</span>
        <span class="p">(</span><span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">,</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">PREPARED</span><span class="p">),</span>
        <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">CLOSED</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_to_root</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">PREPARED</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expect_state</span><span class="p">(</span><span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">PREPARED</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_impl</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">conn</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">should_commit</span><span class="p">,</span> <span class="n">autoclose</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">should_commit</span><span class="p">:</span>
                    <span class="n">trans</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">COMMITTED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_commit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_remove_snapshot</span><span class="p">()</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expect_state</span><span class="p">(</span><span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">CLOSED</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">_to_root</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">commit</span><span class="p">(</span><span class="n">_to_root</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@_StateChange</span><span class="o">.</span><span class="n">declare_states</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">,</span>
            <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">DEACTIVE</span><span class="p">,</span>
            <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">PREPARED</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">CLOSED</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">_capture_exception</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">_to_root</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_transaction</span>
        <span class="k">assert</span> <span class="n">stx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">stx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subtransaction</span> <span class="ow">in</span> <span class="n">stx</span><span class="o">.</span><span class="n">_iterate_self_and_parents</span><span class="p">(</span><span class="n">upto</span><span class="o">=</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">subtransaction</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">boundary</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">rollback_err</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">,</span>
            <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">PREPARED</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">for</span> <span class="n">transaction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iterate_self_and_parents</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">transaction</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">transaction</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">transaction</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                            <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

                        <span class="n">transaction</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">DEACTIVE</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_rollback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">rollback_err</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="n">transaction</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">DEACTIVE</span>
                        <span class="n">transaction</span><span class="o">.</span><span class="n">_restore_snapshot</span><span class="p">(</span>
                            <span class="n">dirty_only</span><span class="o">=</span><span class="n">transaction</span><span class="o">.</span><span class="n">nested</span>
                        <span class="p">)</span>
                    <span class="n">boundary</span> <span class="o">=</span> <span class="n">transaction</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">transaction</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">DEACTIVE</span>

        <span class="n">sess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">rollback_err</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sess</span><span class="o">.</span><span class="n">_is_clean</span><span class="p">():</span>
            <span class="c1"># if items were added, deleted, or mutated</span>
            <span class="c1"># here, we need to re-restore the snapshot</span>
            <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Session&#39;s state has been changed on &quot;</span>
                <span class="s2">&quot;a non-active transaction - this state &quot;</span>
                <span class="s2">&quot;will be discarded.&quot;</span>
            <span class="p">)</span>
            <span class="n">boundary</span><span class="o">.</span><span class="n">_restore_snapshot</span><span class="p">(</span><span class="n">dirty_only</span><span class="o">=</span><span class="n">boundary</span><span class="o">.</span><span class="n">nested</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expect_state</span><span class="p">(</span><span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">CLOSED</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">and</span> <span class="n">_capture_exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_rollback_exception</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">rollback_err</span> <span class="ow">and</span> <span class="n">rollback_err</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="n">rollback_err</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">rollback_err</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">sess</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_soft_rollback</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_to_root</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="n">_to_root</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@_StateChange</span><span class="o">.</span><span class="n">declare_states</span><span class="p">(</span>
        <span class="n">_StateChangeStates</span><span class="o">.</span><span class="n">ANY</span><span class="p">,</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">CLOSED</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invalidate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_nested_transaction</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_previous_nested_transaction</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_transaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

        <span class="k">for</span> <span class="n">connection</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">should_commit</span><span class="p">,</span> <span class="n">autoclose</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">invalidate</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">connection</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">should_commit</span> <span class="ow">and</span> <span class="n">transaction</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
                <span class="n">transaction</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">autoclose</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">CLOSED</span>
        <span class="n">sess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span>

        <span class="c1"># TODO: these two None sets were historically after the</span>
        <span class="c1"># event hook below, and in 2.0 I changed it this way for some reason,</span>
        <span class="c1"># and I remember there being a reason, but not what it was.</span>
        <span class="c1"># Why do we need to get rid of them at all?  test_memusage::CycleTest</span>
        <span class="c1"># passes with these commented out.</span>
        <span class="c1"># self.session = None  # type: ignore</span>
        <span class="c1"># self._connections = None  # type: ignore</span>

        <span class="n">sess</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_transaction_end</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_subject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Session</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span>

    <span class="k">def</span> <span class="nf">_transaction_is_active</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">ACTIVE</span>

    <span class="k">def</span> <span class="nf">_transaction_is_closed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">SessionTransactionState</span><span class="o">.</span><span class="n">CLOSED</span>

    <span class="k">def</span> <span class="nf">_rollback_can_be_called</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">COMMITTED</span><span class="p">,</span> <span class="n">CLOSED</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_SessionCloseState</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">ACTIVE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">CLOSED</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">CLOSE_IS_RESET</span> <span class="o">=</span> <span class="mi">3</span>


<span class="k">class</span> <span class="nc">Session</span><span class="p">(</span><span class="n">_SessionClassMethods</span><span class="p">,</span> <span class="n">EventTarget</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Manages persistence operations for ORM-mapped objects.</span>

<span class="sd">    The :class:`_orm.Session` is **not safe for use in concurrent threads.**.</span>
<span class="sd">    See :ref:`session_faq_threadsafe` for background.</span>

<span class="sd">    The Session&#39;s usage paradigm is described at :doc:`/orm/session`.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_is_asyncio</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">dispatch</span><span class="p">:</span> <span class="n">dispatcher</span><span class="p">[</span><span class="n">Session</span><span class="p">]</span>

    <span class="n">identity_map</span><span class="p">:</span> <span class="n">IdentityMap</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A mapping of object identities to objects themselves.</span>

<span class="sd">    Iterating through ``Session.identity_map.values()`` provides</span>
<span class="sd">    access to the full set of persistent objects (i.e., those</span>
<span class="sd">    that have row identity) currently in the session.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.identity_key` - helper function to produce the keys used</span>
<span class="sd">        in this dictionary.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_new</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span>
    <span class="n">_deleted</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">]</span>
    <span class="n">bind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Engine</span><span class="p">,</span> <span class="n">Connection</span><span class="p">]]</span>
    <span class="n">__binds</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">_SessionBindKey</span><span class="p">,</span> <span class="n">_SessionBind</span><span class="p">]</span>
    <span class="n">_flushing</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_warn_on_events</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">_transaction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SessionTransaction</span><span class="p">]</span>
    <span class="n">_nested_transaction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SessionTransaction</span><span class="p">]</span>
    <span class="n">hash_key</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">autoflush</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">expire_on_commit</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">enable_baked_queries</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">twophase</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">join_transaction_mode</span><span class="p">:</span> <span class="n">JoinTransactionMode</span>
    <span class="n">_query_cls</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Query</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span>
    <span class="n">_close_state</span><span class="p">:</span> <span class="n">_SessionCloseState</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_SessionBind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">autoflush</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">future</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">expire_on_commit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">autobegin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">twophase</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">binds</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">_SessionBindKey</span><span class="p">,</span> <span class="n">_SessionBind</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">enable_baked_queries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_InfoType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">query_cls</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Query</span><span class="p">[</span><span class="n">Any</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">autocommit</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">join_transaction_mode</span><span class="p">:</span> <span class="n">JoinTransactionMode</span> <span class="o">=</span> <span class="s2">&quot;conditional_savepoint&quot;</span><span class="p">,</span>
        <span class="n">close_resets_only</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">_NoArg</span><span class="p">]</span> <span class="o">=</span> <span class="n">_NoArg</span><span class="o">.</span><span class="n">NO_ARG</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Construct a new :class:`_orm.Session`.</span>

<span class="sd">        See also the :class:`.sessionmaker` function which is used to</span>
<span class="sd">        generate a :class:`.Session`-producing callable with a given</span>
<span class="sd">        set of arguments.</span>

<span class="sd">        :param autoflush: When ``True``, all query operations will issue a</span>
<span class="sd">           :meth:`~.Session.flush` call to this ``Session`` before proceeding.</span>
<span class="sd">           This is a convenience feature so that :meth:`~.Session.flush` need</span>
<span class="sd">           not be called repeatedly in order for database queries to retrieve</span>
<span class="sd">           results.</span>

<span class="sd">           .. seealso::</span>

<span class="sd">               :ref:`session_flushing` - additional background on autoflush</span>

<span class="sd">        :param autobegin: Automatically start transactions (i.e. equivalent to</span>
<span class="sd">           invoking :meth:`_orm.Session.begin`) when database access is</span>
<span class="sd">           requested by an operation.   Defaults to ``True``.    Set to</span>
<span class="sd">           ``False`` to prevent a :class:`_orm.Session` from implicitly</span>
<span class="sd">           beginning transactions after construction, as well as after any of</span>
<span class="sd">           the :meth:`_orm.Session.rollback`, :meth:`_orm.Session.commit`,</span>
<span class="sd">           or :meth:`_orm.Session.close` methods are called.</span>

<span class="sd">           .. versionadded:: 2.0</span>

<span class="sd">           .. seealso::</span>

<span class="sd">                :ref:`session_autobegin_disable`</span>

<span class="sd">        :param bind: An optional :class:`_engine.Engine` or</span>
<span class="sd">           :class:`_engine.Connection` to</span>
<span class="sd">           which this ``Session`` should be bound. When specified, all SQL</span>
<span class="sd">           operations performed by this session will execute via this</span>
<span class="sd">           connectable.</span>

<span class="sd">        :param binds: A dictionary which may specify any number of</span>
<span class="sd">           :class:`_engine.Engine` or :class:`_engine.Connection`</span>
<span class="sd">           objects as the source of</span>
<span class="sd">           connectivity for SQL operations on a per-entity basis.   The keys</span>
<span class="sd">           of the dictionary consist of any series of mapped classes,</span>
<span class="sd">           arbitrary Python classes that are bases for mapped classes,</span>
<span class="sd">           :class:`_schema.Table` objects and :class:`_orm.Mapper` objects.</span>
<span class="sd">           The</span>
<span class="sd">           values of the dictionary are then instances of</span>
<span class="sd">           :class:`_engine.Engine`</span>
<span class="sd">           or less commonly :class:`_engine.Connection` objects.</span>
<span class="sd">           Operations which</span>
<span class="sd">           proceed relative to a particular mapped class will consult this</span>
<span class="sd">           dictionary for the closest matching entity in order to determine</span>
<span class="sd">           which :class:`_engine.Engine` should be used for a particular SQL</span>
<span class="sd">           operation.    The complete heuristics for resolution are</span>
<span class="sd">           described at :meth:`.Session.get_bind`.  Usage looks like::</span>

<span class="sd">            Session = sessionmaker(binds={</span>
<span class="sd">                SomeMappedClass: create_engine(&#39;postgresql+psycopg2://engine1&#39;),</span>
<span class="sd">                SomeDeclarativeBase: create_engine(&#39;postgresql+psycopg2://engine2&#39;),</span>
<span class="sd">                some_mapper: create_engine(&#39;postgresql+psycopg2://engine3&#39;),</span>
<span class="sd">                some_table: create_engine(&#39;postgresql+psycopg2://engine4&#39;),</span>
<span class="sd">                })</span>

<span class="sd">           .. seealso::</span>

<span class="sd">                :ref:`session_partitioning`</span>

<span class="sd">                :meth:`.Session.bind_mapper`</span>

<span class="sd">                :meth:`.Session.bind_table`</span>

<span class="sd">                :meth:`.Session.get_bind`</span>


<span class="sd">        :param \class_: Specify an alternate class other than</span>
<span class="sd">           ``sqlalchemy.orm.session.Session`` which should be used by the</span>
<span class="sd">           returned class. This is the only argument that is local to the</span>
<span class="sd">           :class:`.sessionmaker` function, and is not sent directly to the</span>
<span class="sd">           constructor for ``Session``.</span>

<span class="sd">        :param enable_baked_queries: legacy; defaults to ``True``.</span>
<span class="sd">           A parameter consumed</span>
<span class="sd">           by the :mod:`sqlalchemy.ext.baked` extension to determine if</span>
<span class="sd">           &quot;baked queries&quot; should be cached, as is the normal operation</span>
<span class="sd">           of this extension.  When set to ``False``, caching as used by</span>
<span class="sd">           this particular extension is disabled.</span>

<span class="sd">           .. versionchanged:: 1.4 The ``sqlalchemy.ext.baked`` extension is</span>
<span class="sd">              legacy and is not used by any of SQLAlchemy&#39;s internals. This</span>
<span class="sd">              flag therefore only affects applications that are making explicit</span>
<span class="sd">              use of this extension within their own code.</span>

<span class="sd">        :param expire_on_commit:  Defaults to ``True``. When ``True``, all</span>
<span class="sd">           instances will be fully expired after each :meth:`~.commit`,</span>
<span class="sd">           so that all attribute/object access subsequent to a completed</span>
<span class="sd">           transaction will load from the most recent database state.</span>

<span class="sd">            .. seealso::</span>

<span class="sd">                :ref:`session_committing`</span>

<span class="sd">        :param future: Deprecated; this flag is always True.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :ref:`migration_20_toplevel`</span>

<span class="sd">        :param info: optional dictionary of arbitrary data to be associated</span>
<span class="sd">           with this :class:`.Session`.  Is available via the</span>
<span class="sd">           :attr:`.Session.info` attribute.  Note the dictionary is copied at</span>
<span class="sd">           construction time so that modifications to the per-</span>
<span class="sd">           :class:`.Session` dictionary will be local to that</span>
<span class="sd">           :class:`.Session`.</span>

<span class="sd">        :param query_cls:  Class which should be used to create new Query</span>
<span class="sd">          objects, as returned by the :meth:`~.Session.query` method.</span>
<span class="sd">          Defaults to :class:`_query.Query`.</span>

<span class="sd">        :param twophase:  When ``True``, all transactions will be started as</span>
<span class="sd">            a &quot;two phase&quot; transaction, i.e. using the &quot;two phase&quot; semantics</span>
<span class="sd">            of the database in use along with an XID.  During a</span>
<span class="sd">            :meth:`~.commit`, after :meth:`~.flush` has been issued for all</span>
<span class="sd">            attached databases, the :meth:`~.TwoPhaseTransaction.prepare`</span>
<span class="sd">            method on each database&#39;s :class:`.TwoPhaseTransaction` will be</span>
<span class="sd">            called. This allows each database to roll back the entire</span>
<span class="sd">            transaction, before each transaction is committed.</span>

<span class="sd">        :param autocommit: the &quot;autocommit&quot; keyword is present for backwards</span>
<span class="sd">            compatibility but must remain at its default value of ``False``.</span>

<span class="sd">        :param join_transaction_mode: Describes the transactional behavior to</span>
<span class="sd">          take when a given bind is a :class:`_engine.Connection` that</span>
<span class="sd">          has already begun a transaction outside the scope of this</span>
<span class="sd">          :class:`_orm.Session`; in other words the</span>
<span class="sd">          :meth:`_engine.Connection.in_transaction()` method returns True.</span>

<span class="sd">          The following behaviors only take effect when the :class:`_orm.Session`</span>
<span class="sd">          **actually makes use of the connection given**; that is, a method</span>
<span class="sd">          such as :meth:`_orm.Session.execute`, :meth:`_orm.Session.connection`,</span>
<span class="sd">          etc. are actually invoked:</span>

<span class="sd">          * ``&quot;conditional_savepoint&quot;`` - this is the default.  if the given</span>
<span class="sd">            :class:`_engine.Connection` is begun within a transaction but</span>
<span class="sd">            does not have a SAVEPOINT, then ``&quot;rollback_only&quot;`` is used.</span>
<span class="sd">            If the :class:`_engine.Connection` is additionally within</span>
<span class="sd">            a SAVEPOINT, in other words</span>
<span class="sd">            :meth:`_engine.Connection.in_nested_transaction()` method returns</span>
<span class="sd">            True, then ``&quot;create_savepoint&quot;`` is used.</span>

<span class="sd">            ``&quot;conditional_savepoint&quot;`` behavior attempts to make use of</span>
<span class="sd">            savepoints in order to keep the state of the existing transaction</span>
<span class="sd">            unchanged, but only if there is already a savepoint in progress;</span>
<span class="sd">            otherwise, it is not assumed that the backend in use has adequate</span>
<span class="sd">            support for SAVEPOINT, as availability of this feature varies.</span>
<span class="sd">            ``&quot;conditional_savepoint&quot;`` also seeks to establish approximate</span>
<span class="sd">            backwards compatibility with previous :class:`_orm.Session`</span>
<span class="sd">            behavior, for applications that are not setting a specific mode. It</span>
<span class="sd">            is recommended that one of the explicit settings be used.</span>

<span class="sd">          * ``&quot;create_savepoint&quot;`` - the :class:`_orm.Session` will use</span>
<span class="sd">            :meth:`_engine.Connection.begin_nested()` in all cases to create</span>
<span class="sd">            its own transaction.  This transaction by its nature rides</span>
<span class="sd">            &quot;on top&quot; of any existing transaction that&#39;s opened on the given</span>
<span class="sd">            :class:`_engine.Connection`; if the underlying database and</span>
<span class="sd">            the driver in use has full, non-broken support for SAVEPOINT, the</span>
<span class="sd">            external transaction will remain unaffected throughout the</span>
<span class="sd">            lifespan of the :class:`_orm.Session`.</span>

<span class="sd">            The ``&quot;create_savepoint&quot;`` mode is the most useful for integrating</span>
<span class="sd">            a :class:`_orm.Session` into a test suite where an externally</span>
<span class="sd">            initiated transaction should remain unaffected; however, it relies</span>
<span class="sd">            on proper SAVEPOINT support from the underlying driver and</span>
<span class="sd">            database.</span>

<span class="sd">            .. tip:: When using SQLite, the SQLite driver included through</span>
<span class="sd">               Python 3.11 does not handle SAVEPOINTs correctly in all cases</span>
<span class="sd">               without workarounds. See the sections</span>
<span class="sd">               :ref:`pysqlite_serializable` and :ref:`aiosqlite_serializable`</span>
<span class="sd">               for details on current workarounds.</span>

<span class="sd">          * ``&quot;control_fully&quot;`` - the :class:`_orm.Session` will take</span>
<span class="sd">            control of the given transaction as its own;</span>
<span class="sd">            :meth:`_orm.Session.commit` will call ``.commit()`` on the</span>
<span class="sd">            transaction, :meth:`_orm.Session.rollback` will call</span>
<span class="sd">            ``.rollback()`` on the transaction, :meth:`_orm.Session.close` will</span>
<span class="sd">            call ``.rollback`` on the transaction.</span>

<span class="sd">            .. tip:: This mode of use is equivalent to how SQLAlchemy 1.4 would</span>
<span class="sd">               handle a :class:`_engine.Connection` given with an existing</span>
<span class="sd">               SAVEPOINT (i.e. :meth:`_engine.Connection.begin_nested`); the</span>
<span class="sd">               :class:`_orm.Session` would take full control of the existing</span>
<span class="sd">               SAVEPOINT.</span>

<span class="sd">          * ``&quot;rollback_only&quot;`` - the :class:`_orm.Session` will take control</span>
<span class="sd">            of the given transaction for ``.rollback()`` calls only;</span>
<span class="sd">            ``.commit()`` calls will not be propagated to the given</span>
<span class="sd">            transaction.  ``.close()`` calls will have no effect on the</span>
<span class="sd">            given transaction.</span>

<span class="sd">            .. tip:: This mode of use is equivalent to how SQLAlchemy 1.4 would</span>
<span class="sd">               handle a :class:`_engine.Connection` given with an existing</span>
<span class="sd">               regular database transaction (i.e.</span>
<span class="sd">               :meth:`_engine.Connection.begin`); the :class:`_orm.Session`</span>
<span class="sd">               would propagate :meth:`_orm.Session.rollback` calls to the</span>
<span class="sd">               underlying transaction, but not :meth:`_orm.Session.commit` or</span>
<span class="sd">               :meth:`_orm.Session.close` calls.</span>

<span class="sd">          .. versionadded:: 2.0.0rc1</span>

<span class="sd">        :param close_resets_only: Defaults to ``True``. Determines if</span>
<span class="sd">          the session should reset itself after calling ``.close()``</span>
<span class="sd">          or should pass in a no longer usable state, disabling re-use.</span>

<span class="sd">          .. versionadded:: 2.0.22 added flag ``close_resets_only``.</span>
<span class="sd">            A future SQLAlchemy version may change the default value of</span>
<span class="sd">            this flag to ``False``.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :ref:`session_closing` - Detail on the semantics of</span>
<span class="sd">            :meth:`_orm.Session.close` and :meth:`_orm.Session.reset`.</span>

<span class="sd">        &quot;&quot;&quot;</span>  <span class="c1"># noqa</span>

        <span class="c1"># considering allowing the &quot;autocommit&quot; keyword to still be accepted</span>
        <span class="c1"># as long as it&#39;s False, so that external test suites, oslo.db etc</span>
        <span class="c1"># continue to function as the argument appears to be passed in lots</span>
        <span class="c1"># of cases including in our own test suite</span>
        <span class="k">if</span> <span class="n">autocommit</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">&quot;autocommit=True is no longer supported&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span> <span class="o">=</span> <span class="n">identity</span><span class="o">.</span><span class="n">WeakInstanceDict</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">future</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">&quot;The &#39;future&#39; parameter passed to &quot;</span>
                <span class="s2">&quot;Session() may only be set to True.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># InstanceState-&gt;object, strong refs object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># same</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nested_transaction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span> <span class="o">=</span> <span class="n">_new_sessionid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autobegin</span> <span class="o">=</span> <span class="n">autobegin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="n">autoflush</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expire_on_commit</span> <span class="o">=</span> <span class="n">expire_on_commit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">enable_baked_queries</span> <span class="o">=</span> <span class="n">enable_baked_queries</span>

        <span class="c1"># the idea is that at some point NO_ARG will warn that in the future</span>
        <span class="c1"># the default will switch to close_resets_only=False.</span>
        <span class="k">if</span> <span class="n">close_resets_only</span> <span class="ow">or</span> <span class="n">close_resets_only</span> <span class="ow">is</span> <span class="n">_NoArg</span><span class="o">.</span><span class="n">NO_ARG</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_state</span> <span class="o">=</span> <span class="n">_SessionCloseState</span><span class="o">.</span><span class="n">CLOSE_IS_RESET</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_state</span> <span class="o">=</span> <span class="n">_SessionCloseState</span><span class="o">.</span><span class="n">ACTIVE</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">join_transaction_mode</span>
            <span class="ow">and</span> <span class="n">join_transaction_mode</span>
            <span class="ow">not</span> <span class="ow">in</span> <span class="n">JoinTransactionMode</span><span class="o">.</span><span class="n">__args__</span>  <span class="c1"># type: ignore</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;invalid selection for join_transaction_mode: &quot;</span>
                <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">join_transaction_mode</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">join_transaction_mode</span> <span class="o">=</span> <span class="n">join_transaction_mode</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">twophase</span> <span class="o">=</span> <span class="n">twophase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query_cls</span> <span class="o">=</span> <span class="n">query_cls</span> <span class="k">if</span> <span class="n">query_cls</span> <span class="k">else</span> <span class="n">query</span><span class="o">.</span><span class="n">Query</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">bind</span> <span class="ow">in</span> <span class="n">binds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_bind</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">bind</span><span class="p">)</span>

        <span class="n">_sessions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="c1"># used by sqlalchemy.engine.util.TransactionalContext</span>
    <span class="n">_trans_context_manager</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TransactionalContext</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">connection_callable</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_ConnectionCallableProto</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_S</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">traceback</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">_maker_context_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">:</span> <span class="n">_S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">_S</span><span class="p">]:</span>
        <span class="k">with</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">():</span>
                <span class="k">yield</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">in_transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if this :class:`_orm.Session` has begun a transaction.</span>

<span class="sd">        .. versionadded:: 1.4</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :attr:`_orm.Session.is_active`</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">in_nested_transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if this :class:`_orm.Session` has begun a nested</span>
<span class="sd">        transaction, e.g. SAVEPOINT.</span>

<span class="sd">        .. versionadded:: 1.4</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nested_transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SessionTransaction</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the current root transaction in progress, if any.</span>

<span class="sd">        .. versionadded:: 1.4</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span>
        <span class="k">while</span> <span class="n">trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">trans</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">return</span> <span class="n">trans</span>

    <span class="k">def</span> <span class="nf">get_nested_transaction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SessionTransaction</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the current nested transaction in progress, if any.</span>

<span class="sd">        .. versionadded:: 1.4</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nested_transaction</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_InfoType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A user-modifiable dictionary.</span>

<span class="sd">        The initial value of this dictionary can be populated using the</span>
<span class="sd">        ``info`` argument to the :class:`.Session` constructor or</span>
<span class="sd">        :class:`.sessionmaker` constructor or factory methods.  The dictionary</span>
<span class="sd">        here is always local to this :class:`.Session` and can be modified</span>
<span class="sd">        independently of all other :class:`.Session` objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_autobegin_t</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">begin</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SessionTransaction</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">begin</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autobegin</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;Autobegin is disabled on this Session; please call &quot;</span>
                    <span class="s2">&quot;session.begin() to start a new transaction&quot;</span>
                <span class="p">)</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">SessionTransaction</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="p">(</span>
                    <span class="n">SessionTransactionOrigin</span><span class="o">.</span><span class="n">BEGIN</span>
                    <span class="k">if</span> <span class="n">begin</span>
                    <span class="k">else</span> <span class="n">SessionTransactionOrigin</span><span class="o">.</span><span class="n">AUTOBEGIN</span>
                <span class="p">),</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span> <span class="ow">is</span> <span class="n">trans</span>
            <span class="k">return</span> <span class="n">trans</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span>

    <span class="k">def</span> <span class="nf">begin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SessionTransaction</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Begin a transaction, or nested transaction,</span>
<span class="sd">        on this :class:`.Session`, if one is not already begun.</span>

<span class="sd">        The :class:`_orm.Session` object features **autobegin** behavior,</span>
<span class="sd">        so that normally it is not necessary to call the</span>
<span class="sd">        :meth:`_orm.Session.begin`</span>
<span class="sd">        method explicitly. However, it may be used in order to control</span>
<span class="sd">        the scope of when the transactional state is begun.</span>

<span class="sd">        When used to begin the outermost transaction, an error is raised</span>
<span class="sd">        if this :class:`.Session` is already inside of a transaction.</span>

<span class="sd">        :param nested: if True, begins a SAVEPOINT transaction and is</span>
<span class="sd">         equivalent to calling :meth:`~.Session.begin_nested`. For</span>
<span class="sd">         documentation on SAVEPOINT transactions, please see</span>
<span class="sd">         :ref:`session_begin_nested`.</span>

<span class="sd">        :return: the :class:`.SessionTransaction` object.  Note that</span>
<span class="sd">         :class:`.SessionTransaction`</span>
<span class="sd">         acts as a Python context manager, allowing :meth:`.Session.begin`</span>
<span class="sd">         to be used in a &quot;with&quot; block.  See :ref:`session_explicit_begin` for</span>
<span class="sd">         an example.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_autobegin`</span>

<span class="sd">            :ref:`unitofwork_transaction`</span>

<span class="sd">            :meth:`.Session.begin_nested`</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span>
        <span class="k">if</span> <span class="n">trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autobegin_t</span><span class="p">(</span><span class="n">begin</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">nested</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">trans</span>

        <span class="k">assert</span> <span class="n">trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">nested</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">_begin</span><span class="p">(</span><span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span> <span class="ow">is</span> <span class="n">trans</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nested_transaction</span> <span class="o">=</span> <span class="n">trans</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;A transaction is already begun on this Session.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">trans</span>  <span class="c1"># needed for __enter__/__exit__ hook</span>

    <span class="k">def</span> <span class="nf">begin_nested</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SessionTransaction</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Begin a &quot;nested&quot; transaction on this Session, e.g. SAVEPOINT.</span>

<span class="sd">        The target database(s) and associated drivers must support SQL</span>
<span class="sd">        SAVEPOINT for this method to function correctly.</span>

<span class="sd">        For documentation on SAVEPOINT</span>
<span class="sd">        transactions, please see :ref:`session_begin_nested`.</span>

<span class="sd">        :return: the :class:`.SessionTransaction` object.  Note that</span>
<span class="sd">         :class:`.SessionTransaction` acts as a context manager, allowing</span>
<span class="sd">         :meth:`.Session.begin_nested` to be used in a &quot;with&quot; block.</span>
<span class="sd">         See :ref:`session_begin_nested` for a usage example.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_begin_nested`</span>

<span class="sd">            :ref:`pysqlite_serializable` - special workarounds required</span>
<span class="sd">            with the SQLite driver in order for SAVEPOINT to work</span>
<span class="sd">            correctly. For asyncio use cases, see the section</span>
<span class="sd">            :ref:`aiosqlite_serializable`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Rollback the current transaction in progress.</span>

<span class="sd">        If no transaction is in progress, this method is a pass-through.</span>

<span class="sd">        The method always rolls back</span>
<span class="sd">        the topmost database transaction, discarding any nested</span>
<span class="sd">        transactions that may be in progress.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_rollback`</span>

<span class="sd">            :ref:`unitofwork_transaction`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="n">_to_root</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flush pending changes and commit the current transaction.</span>

<span class="sd">        When the COMMIT operation is complete, all objects are fully</span>
<span class="sd">        :term:`expired`, erasing their internal contents, which will be</span>
<span class="sd">        automatically re-loaded when the objects are next accessed. In the</span>
<span class="sd">        interim, these objects are in an expired state and will not function if</span>
<span class="sd">        they are :term:`detached` from the :class:`.Session`. Additionally,</span>
<span class="sd">        this re-load operation is not supported when using asyncio-oriented</span>
<span class="sd">        APIs. The :paramref:`.Session.expire_on_commit` parameter may be used</span>
<span class="sd">        to disable this behavior.</span>

<span class="sd">        When there is no transaction in place for the :class:`.Session`,</span>
<span class="sd">        indicating that no operations were invoked on this :class:`.Session`</span>
<span class="sd">        since the previous call to :meth:`.Session.commit`, the method will</span>
<span class="sd">        begin and commit an internal-only &quot;logical&quot; transaction, that does not</span>
<span class="sd">        normally affect the database unless pending flush changes were</span>
<span class="sd">        detected, but will still invoke event handlers and object expiration</span>
<span class="sd">        rules.</span>

<span class="sd">        The outermost database transaction is committed unconditionally,</span>
<span class="sd">        automatically releasing any SAVEPOINTs in effect.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_committing`</span>

<span class="sd">            :ref:`unitofwork_transaction`</span>

<span class="sd">            :ref:`asyncio_orm_avoid_lazyloads`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span>
        <span class="k">if</span> <span class="n">trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autobegin_t</span><span class="p">()</span>

        <span class="n">trans</span><span class="o">.</span><span class="n">commit</span><span class="p">(</span><span class="n">_to_root</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Prepare the current transaction in progress for two phase commit.</span>

<span class="sd">        If no transaction is in progress, this method raises an</span>
<span class="sd">        :exc:`~sqlalchemy.exc.InvalidRequestError`.</span>

<span class="sd">        Only root transactions of two phase sessions can be prepared. If the</span>
<span class="sd">        current transaction is not such, an</span>
<span class="sd">        :exc:`~sqlalchemy.exc.InvalidRequestError` is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span>
        <span class="k">if</span> <span class="n">trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autobegin_t</span><span class="p">()</span>

        <span class="n">trans</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">connection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CoreExecuteOptionsParameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Connection</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return a :class:`_engine.Connection` object corresponding to this</span>
<span class="sd">        :class:`.Session` object&#39;s transactional state.</span>

<span class="sd">        Either the :class:`_engine.Connection` corresponding to the current</span>
<span class="sd">        transaction is returned, or if no transaction is in progress, a new</span>
<span class="sd">        one is begun and the :class:`_engine.Connection`</span>
<span class="sd">        returned (note that no</span>
<span class="sd">        transactional state is established with the DBAPI until the first</span>
<span class="sd">        SQL statement is emitted).</span>

<span class="sd">        Ambiguity in multi-bind or unbound :class:`.Session` objects can be</span>
<span class="sd">        resolved through any of the optional keyword arguments.   This</span>
<span class="sd">        ultimately makes usage of the :meth:`.get_bind` method for resolution.</span>

<span class="sd">        :param bind_arguments: dictionary of bind arguments.  May include</span>
<span class="sd">         &quot;mapper&quot;, &quot;bind&quot;, &quot;clause&quot;, other custom arguments that are passed</span>
<span class="sd">         to :meth:`.Session.get_bind`.</span>

<span class="sd">        :param execution_options: a dictionary of execution options that will</span>
<span class="sd">         be passed to :meth:`_engine.Connection.execution_options`, **when the</span>
<span class="sd">         connection is first procured only**.   If the connection is already</span>
<span class="sd">         present within the :class:`.Session`, a warning is emitted and</span>
<span class="sd">         the arguments are ignored.</span>

<span class="sd">         .. seealso::</span>

<span class="sd">            :ref:`session_transaction_isolation`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">bind_arguments</span><span class="p">:</span>
            <span class="n">bind</span> <span class="o">=</span> <span class="n">bind_arguments</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;bind&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">bind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bind</span><span class="p">(</span><span class="o">**</span><span class="n">bind_arguments</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bind</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span>
            <span class="n">bind</span><span class="p">,</span>
            <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_connection_for_bind</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">engine</span><span class="p">:</span> <span class="n">_SessionBind</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CoreExecuteOptionsParameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Connection</span><span class="p">:</span>
        <span class="n">TransactionalContext</span><span class="o">.</span><span class="n">_trans_ctx_check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span>
        <span class="k">if</span> <span class="n">trans</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autobegin_t</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">trans</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span><span class="n">engine</span><span class="p">,</span> <span class="n">execution_options</span><span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">_execute_internal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">Executable</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreSingleExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_parent_execute_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_add_event</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_scalar_result</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">_execute_internal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">Executable</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_parent_execute_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_add_event</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_scalar_result</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">_execute_internal</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">Executable</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_parent_execute_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_add_event</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_scalar_result</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="n">statement</span> <span class="o">=</span> <span class="n">coercions</span><span class="o">.</span><span class="n">expect</span><span class="p">(</span><span class="n">roles</span><span class="o">.</span><span class="n">StatementRole</span><span class="p">,</span> <span class="n">statement</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">bind_arguments</span><span class="p">:</span>
            <span class="n">bind_arguments</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bind_arguments</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">bind_arguments</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">statement</span><span class="o">.</span><span class="n">_propagate_attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;compile_state_plugin&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="o">==</span> <span class="s2">&quot;orm&quot;</span>
        <span class="p">):</span>
            <span class="n">compile_state_cls</span> <span class="o">=</span> <span class="n">CompileState</span><span class="o">.</span><span class="n">_get_plugin_class_for_plugin</span><span class="p">(</span>
                <span class="n">statement</span><span class="p">,</span> <span class="s2">&quot;orm&quot;</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                    <span class="n">compile_state_cls</span><span class="p">,</span> <span class="n">context</span><span class="o">.</span><span class="n">AbstractORMCompileState</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compile_state_cls</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">bind_arguments</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;clause&quot;</span><span class="p">,</span> <span class="n">statement</span><span class="p">)</span>

        <span class="n">execution_options</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">coerce_to_immutabledict</span><span class="p">(</span><span class="n">execution_options</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_parent_execute_state</span><span class="p">:</span>
            <span class="n">events_todo</span> <span class="o">=</span> <span class="n">_parent_execute_state</span><span class="o">.</span><span class="n">_remaining_events</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">events_todo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">do_orm_execute</span>
            <span class="k">if</span> <span class="n">_add_event</span><span class="p">:</span>
                <span class="n">events_todo</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">events_todo</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">_add_event</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">events_todo</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">compile_state_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># for event handlers, do the orm_pre_session_exec</span>
                <span class="c1"># pass ahead of the event handlers, so that things like</span>
                <span class="c1"># .load_options, .update_delete_options etc. are populated.</span>
                <span class="c1"># is_pre_event=True allows the hook to hold off on things</span>
                <span class="c1"># it doesn&#39;t want to do twice, including autoflush as well</span>
                <span class="c1"># as &quot;pre fetch&quot; for DML, etc.</span>
                <span class="p">(</span>
                    <span class="n">statement</span><span class="p">,</span>
                    <span class="n">execution_options</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">=</span> <span class="n">compile_state_cls</span><span class="o">.</span><span class="n">orm_pre_session_exec</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">statement</span><span class="p">,</span>
                    <span class="n">params</span><span class="p">,</span>
                    <span class="n">execution_options</span><span class="p">,</span>
                    <span class="n">bind_arguments</span><span class="p">,</span>
                    <span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">orm_exec_state</span> <span class="o">=</span> <span class="n">ORMExecuteState</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">statement</span><span class="p">,</span>
                <span class="n">params</span><span class="p">,</span>
                <span class="n">execution_options</span><span class="p">,</span>
                <span class="n">bind_arguments</span><span class="p">,</span>
                <span class="n">compile_state_cls</span><span class="p">,</span>
                <span class="n">events_todo</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">events_todo</span><span class="p">):</span>
                <span class="n">orm_exec_state</span><span class="o">.</span><span class="n">_starting_event_idx</span> <span class="o">=</span> <span class="n">idx</span>
                <span class="n">fn_result</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Result</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="n">orm_exec_state</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fn_result</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">_scalar_result</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">fn_result</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">fn_result</span>

            <span class="n">statement</span> <span class="o">=</span> <span class="n">orm_exec_state</span><span class="o">.</span><span class="n">statement</span>
            <span class="n">execution_options</span> <span class="o">=</span> <span class="n">orm_exec_state</span><span class="o">.</span><span class="n">local_execution_options</span>

        <span class="k">if</span> <span class="n">compile_state_cls</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># now run orm_pre_session_exec() &quot;for real&quot;.   if there were</span>
            <span class="c1"># event hooks, this will re-run the steps that interpret</span>
            <span class="c1"># new execution_options into load_options / update_delete_options,</span>
            <span class="c1"># which we assume the event hook might have updated.</span>
            <span class="c1"># autoflush will also be invoked in this step if enabled.</span>
            <span class="p">(</span>
                <span class="n">statement</span><span class="p">,</span>
                <span class="n">execution_options</span><span class="p">,</span>
            <span class="p">)</span> <span class="o">=</span> <span class="n">compile_state_cls</span><span class="o">.</span><span class="n">orm_pre_session_exec</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">statement</span><span class="p">,</span>
                <span class="n">params</span><span class="p">,</span>
                <span class="n">execution_options</span><span class="p">,</span>
                <span class="n">bind_arguments</span><span class="p">,</span>
                <span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bind</span><span class="p">(</span><span class="o">**</span><span class="n">bind_arguments</span><span class="p">)</span>

        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span><span class="n">bind</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_scalar_result</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">compile_state_cls</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
                <span class="n">params</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">_CoreSingleExecuteParams</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">conn</span><span class="o">.</span><span class="n">scalar</span><span class="p">(</span>
                <span class="n">statement</span><span class="p">,</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{},</span> <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">compile_state_cls</span><span class="p">:</span>
            <span class="n">result</span><span class="p">:</span> <span class="n">Result</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">compile_state_cls</span><span class="o">.</span><span class="n">orm_execute_statement</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">statement</span><span class="p">,</span>
                <span class="n">params</span> <span class="ow">or</span> <span class="p">{},</span>
                <span class="n">execution_options</span><span class="p">,</span>
                <span class="n">bind_arguments</span><span class="p">,</span>
                <span class="n">conn</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
                <span class="n">statement</span><span class="p">,</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{},</span> <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">_scalar_result</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">TypedReturnsRows</span><span class="p">[</span><span class="n">_T</span><span class="p">],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_parent_execute_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_add_event</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">[</span><span class="n">_T</span><span class="p">]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">UpdateBase</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_parent_execute_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_add_event</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CursorResult</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">Executable</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_parent_execute_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_add_event</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">Executable</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_parent_execute_state</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_add_event</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Result</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Execute a SQL expression construct.</span>

<span class="sd">        Returns a :class:`_engine.Result` object representing</span>
<span class="sd">        results of the statement execution.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            from sqlalchemy import select</span>
<span class="sd">            result = session.execute(</span>
<span class="sd">                select(User).where(User.id == 5)</span>
<span class="sd">            )</span>

<span class="sd">        The API contract of :meth:`_orm.Session.execute` is similar to that</span>
<span class="sd">        of :meth:`_engine.Connection.execute`, the :term:`2.0 style` version</span>
<span class="sd">        of :class:`_engine.Connection`.</span>

<span class="sd">        .. versionchanged:: 1.4 the :meth:`_orm.Session.execute` method is</span>
<span class="sd">           now the primary point of ORM statement execution when using</span>
<span class="sd">           :term:`2.0 style` ORM usage.</span>

<span class="sd">        :param statement:</span>
<span class="sd">            An executable statement (i.e. an :class:`.Executable` expression</span>
<span class="sd">            such as :func:`_expression.select`).</span>

<span class="sd">        :param params:</span>
<span class="sd">            Optional dictionary, or list of dictionaries, containing</span>
<span class="sd">            bound parameter values.   If a single dictionary, single-row</span>
<span class="sd">            execution occurs; if a list of dictionaries, an</span>
<span class="sd">            &quot;executemany&quot; will be invoked.  The keys in each dictionary</span>
<span class="sd">            must correspond to parameter names present in the statement.</span>

<span class="sd">        :param execution_options: optional dictionary of execution options,</span>
<span class="sd">         which will be associated with the statement execution.  This</span>
<span class="sd">         dictionary can provide a subset of the options that are accepted</span>
<span class="sd">         by :meth:`_engine.Connection.execution_options`, and may also</span>
<span class="sd">         provide additional options understood only in an ORM context.</span>

<span class="sd">         .. seealso::</span>

<span class="sd">            :ref:`orm_queryguide_execution_options` - ORM-specific execution</span>
<span class="sd">            options</span>

<span class="sd">        :param bind_arguments: dictionary of additional arguments to determine</span>
<span class="sd">         the bind.  May include &quot;mapper&quot;, &quot;bind&quot;, or other custom arguments.</span>
<span class="sd">         Contents of this dictionary are passed to the</span>
<span class="sd">         :meth:`.Session.get_bind` method.</span>

<span class="sd">        :return: a :class:`_engine.Result` object.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_internal</span><span class="p">(</span>
            <span class="n">statement</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span><span class="p">,</span>
            <span class="n">bind_arguments</span><span class="o">=</span><span class="n">bind_arguments</span><span class="p">,</span>
            <span class="n">_parent_execute_state</span><span class="o">=</span><span class="n">_parent_execute_state</span><span class="p">,</span>
            <span class="n">_add_event</span><span class="o">=</span><span class="n">_add_event</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">TypedReturnsRows</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_T</span><span class="p">]],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreSingleExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_T</span><span class="p">]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">Executable</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreSingleExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">Executable</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreSingleExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute a statement and return a scalar result.</span>

<span class="sd">        Usage and parameters are the same as that of</span>
<span class="sd">        :meth:`_orm.Session.execute`; the return result is a scalar Python</span>
<span class="sd">        value.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_internal</span><span class="p">(</span>
            <span class="n">statement</span><span class="p">,</span>
            <span class="n">params</span><span class="p">,</span>
            <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span><span class="p">,</span>
            <span class="n">bind_arguments</span><span class="o">=</span><span class="n">bind_arguments</span><span class="p">,</span>
            <span class="n">_scalar_result</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kw</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">scalars</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">TypedReturnsRows</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_T</span><span class="p">]],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ScalarResult</span><span class="p">[</span><span class="n">_T</span><span class="p">]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">scalars</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">Executable</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ScalarResult</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">scalars</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">statement</span><span class="p">:</span> <span class="n">Executable</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_CoreAnyExecuteParams</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ScalarResult</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute a statement and return the results as scalars.</span>

<span class="sd">        Usage and parameters are the same as that of</span>
<span class="sd">        :meth:`_orm.Session.execute`; the return result is a</span>
<span class="sd">        :class:`_result.ScalarResult` filtering object which</span>
<span class="sd">        will return single elements rather than :class:`_row.Row` objects.</span>

<span class="sd">        :return:  a :class:`_result.ScalarResult` object</span>

<span class="sd">        .. versionadded:: 1.4.24 Added :meth:`_orm.Session.scalars`</span>

<span class="sd">        .. versionadded:: 1.4.26 Added :meth:`_orm.scoped_session.scalars`</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`orm_queryguide_select_orm_entities` - contrasts the behavior</span>
<span class="sd">            of :meth:`_orm.Session.execute` to :meth:`_orm.Session.scalars`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_execute_internal</span><span class="p">(</span>
            <span class="n">statement</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span>
            <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span><span class="p">,</span>
            <span class="n">bind_arguments</span><span class="o">=</span><span class="n">bind_arguments</span><span class="p">,</span>
            <span class="n">_scalar_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># mypy appreciates this</span>
            <span class="o">**</span><span class="n">kw</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">scalars</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Close out the transactional resources and ORM objects used by this</span>
<span class="sd">        :class:`_orm.Session`.</span>

<span class="sd">        This expunges all ORM objects associated with this</span>
<span class="sd">        :class:`_orm.Session`, ends any transaction in progress and</span>
<span class="sd">        :term:`releases` any :class:`_engine.Connection` objects which this</span>
<span class="sd">        :class:`_orm.Session` itself has checked out from associated</span>
<span class="sd">        :class:`_engine.Engine` objects. The operation then leaves the</span>
<span class="sd">        :class:`_orm.Session` in a state which it may be used again.</span>

<span class="sd">        .. tip::</span>

<span class="sd">            In the default running mode the :meth:`_orm.Session.close`</span>
<span class="sd">            method **does not prevent the Session from being used again**.</span>
<span class="sd">            The :class:`_orm.Session` itself does not actually have a</span>
<span class="sd">            distinct &quot;closed&quot; state; it merely means</span>
<span class="sd">            the :class:`_orm.Session` will release all database connections</span>
<span class="sd">            and ORM objects.</span>

<span class="sd">            Setting the parameter :paramref:`_orm.Session.close_resets_only`</span>
<span class="sd">            to ``False`` will instead make the ``close`` final, meaning that</span>
<span class="sd">            any further action on the session will be forbidden.</span>

<span class="sd">        .. versionchanged:: 1.4  The :meth:`.Session.close` method does not</span>
<span class="sd">           immediately create a new :class:`.SessionTransaction` object;</span>
<span class="sd">           instead, the new :class:`.SessionTransaction` is created only if</span>
<span class="sd">           the :class:`.Session` is used again for a database operation.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_closing` - detail on the semantics of</span>
<span class="sd">            :meth:`_orm.Session.close` and :meth:`_orm.Session.reset`.</span>

<span class="sd">            :meth:`_orm.Session.reset` - a similar method that behaves like</span>
<span class="sd">            ``close()`` with  the parameter</span>
<span class="sd">            :paramref:`_orm.Session.close_resets_only` set to ``True``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_impl</span><span class="p">(</span><span class="n">invalidate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Close out the transactional resources and ORM objects used by this</span>
<span class="sd">        :class:`_orm.Session`, resetting the session to its initial state.</span>

<span class="sd">        This method provides for same &quot;reset-only&quot; behavior that the</span>
<span class="sd">        :meth:`_orm.Session.close` method has provided historically, where the</span>
<span class="sd">        state of the :class:`_orm.Session` is reset as though the object were</span>
<span class="sd">        brand new, and ready to be used again.</span>
<span class="sd">        This method may then be useful for :class:`_orm.Session` objects</span>
<span class="sd">        which set :paramref:`_orm.Session.close_resets_only` to ``False``,</span>
<span class="sd">        so that &quot;reset only&quot; behavior is still available.</span>

<span class="sd">        .. versionadded:: 2.0.22</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_closing` - detail on the semantics of</span>
<span class="sd">            :meth:`_orm.Session.close` and :meth:`_orm.Session.reset`.</span>

<span class="sd">            :meth:`_orm.Session.close` - a similar method will additionally</span>
<span class="sd">            prevent re-use of the Session when the parameter</span>
<span class="sd">            :paramref:`_orm.Session.close_resets_only` is set to ``False``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_impl</span><span class="p">(</span><span class="n">invalidate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">is_reset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Close this Session, using connection invalidation.</span>

<span class="sd">        This is a variant of :meth:`.Session.close` that will additionally</span>
<span class="sd">        ensure that the :meth:`_engine.Connection.invalidate`</span>
<span class="sd">        method will be called on each :class:`_engine.Connection` object</span>
<span class="sd">        that is currently in use for a transaction (typically there is only</span>
<span class="sd">        one connection unless the :class:`_orm.Session` is used with</span>
<span class="sd">        multiple engines).</span>

<span class="sd">        This can be called when the database is known to be in a state where</span>
<span class="sd">        the connections are no longer safe to be used.</span>

<span class="sd">        Below illustrates a scenario when using `gevent</span>
<span class="sd">        &lt;https://www.gevent.org/&gt;`_, which can produce ``Timeout`` exceptions</span>
<span class="sd">        that may mean the underlying connection should be discarded::</span>

<span class="sd">            import gevent</span>

<span class="sd">            try:</span>
<span class="sd">                sess = Session()</span>
<span class="sd">                sess.add(User())</span>
<span class="sd">                sess.commit()</span>
<span class="sd">            except gevent.Timeout:</span>
<span class="sd">                sess.invalidate()</span>
<span class="sd">                raise</span>
<span class="sd">            except:</span>
<span class="sd">                sess.rollback()</span>
<span class="sd">                raise</span>

<span class="sd">        The method additionally does everything that :meth:`_orm.Session.close`</span>
<span class="sd">        does, including that all ORM objects are expunged.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_impl</span><span class="p">(</span><span class="n">invalidate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_close_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invalidate</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">is_reset</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_reset</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_state</span> <span class="ow">is</span> <span class="n">_SessionCloseState</span><span class="o">.</span><span class="n">ACTIVE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_state</span> <span class="o">=</span> <span class="n">_SessionCloseState</span><span class="o">.</span><span class="n">CLOSED</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expunge_all</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">transaction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="o">.</span><span class="n">_iterate_self_and_parents</span><span class="p">():</span>
                <span class="n">transaction</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">invalidate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expunge_all</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove all object instances from this ``Session``.</span>

<span class="sd">        This is equivalent to calling ``expunge(obj)`` on all objects in this</span>
<span class="sd">        ``Session``.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">all_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">()</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_kill</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span> <span class="o">=</span> <span class="n">identity</span><span class="o">.</span><span class="n">WeakInstanceDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_detach_states</span><span class="p">(</span><span class="n">all_states</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">_SessionBindKey</span><span class="p">,</span> <span class="n">bind</span><span class="p">:</span> <span class="n">_SessionBind</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">NoInspectionAvailable</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                    <span class="s2">&quot;Not an acceptable bind target: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">insp</span><span class="p">,</span> <span class="n">Inspectable</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">insp</span><span class="p">,</span> <span class="n">TableClause</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">insp</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
            <span class="k">elif</span> <span class="n">insp_is_mapper</span><span class="p">(</span><span class="n">insp</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">insp</span><span class="o">.</span><span class="n">class_</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
                <span class="k">for</span> <span class="n">_selectable</span> <span class="ow">in</span> <span class="n">insp</span><span class="o">.</span><span class="n">_all_tables</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">_selectable</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                    <span class="s2">&quot;Not an acceptable bind target: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">bind_mapper</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">:</span> <span class="n">_EntityBindKey</span><span class="p">[</span><span class="n">_O</span><span class="p">],</span> <span class="n">bind</span><span class="p">:</span> <span class="n">_SessionBind</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Associate a :class:`_orm.Mapper` or arbitrary Python class with a</span>
<span class="sd">        &quot;bind&quot;, e.g. an :class:`_engine.Engine` or</span>
<span class="sd">        :class:`_engine.Connection`.</span>

<span class="sd">        The given entity is added to a lookup used by the</span>
<span class="sd">        :meth:`.Session.get_bind` method.</span>

<span class="sd">        :param mapper: a :class:`_orm.Mapper` object,</span>
<span class="sd">         or an instance of a mapped</span>
<span class="sd">         class, or any Python class that is the base of a set of mapped</span>
<span class="sd">         classes.</span>

<span class="sd">        :param bind: an :class:`_engine.Engine` or :class:`_engine.Connection`</span>
<span class="sd">                    object.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_partitioning`</span>

<span class="sd">            :paramref:`.Session.binds`</span>

<span class="sd">            :meth:`.Session.bind_table`</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_bind</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">bind</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bind_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">:</span> <span class="n">TableClause</span><span class="p">,</span> <span class="n">bind</span><span class="p">:</span> <span class="n">_SessionBind</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Associate a :class:`_schema.Table` with a &quot;bind&quot;, e.g. an</span>
<span class="sd">        :class:`_engine.Engine`</span>
<span class="sd">        or :class:`_engine.Connection`.</span>

<span class="sd">        The given :class:`_schema.Table` is added to a lookup used by the</span>
<span class="sd">        :meth:`.Session.get_bind` method.</span>

<span class="sd">        :param table: a :class:`_schema.Table` object,</span>
<span class="sd">         which is typically the target</span>
<span class="sd">         of an ORM mapping, or is present within a selectable that is</span>
<span class="sd">         mapped.</span>

<span class="sd">        :param bind: an :class:`_engine.Engine` or :class:`_engine.Connection`</span>
<span class="sd">         object.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_partitioning`</span>

<span class="sd">            :paramref:`.Session.binds`</span>

<span class="sd">            :meth:`.Session.bind_mapper`</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_bind</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">bind</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_bind</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_EntityBindKey</span><span class="p">[</span><span class="n">_O</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">clause</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ClauseElement</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_SessionBind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_sa_skip_events</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">_sa_skip_for_implicit_returning</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Engine</span><span class="p">,</span> <span class="n">Connection</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a &quot;bind&quot; to which this :class:`.Session` is bound.</span>

<span class="sd">        The &quot;bind&quot; is usually an instance of :class:`_engine.Engine`,</span>
<span class="sd">        except in the case where the :class:`.Session` has been</span>
<span class="sd">        explicitly bound directly to a :class:`_engine.Connection`.</span>

<span class="sd">        For a multiply-bound or unbound :class:`.Session`, the</span>
<span class="sd">        ``mapper`` or ``clause`` arguments are used to determine the</span>
<span class="sd">        appropriate bind to return.</span>

<span class="sd">        Note that the &quot;mapper&quot; argument is usually present</span>
<span class="sd">        when :meth:`.Session.get_bind` is called via an ORM</span>
<span class="sd">        operation such as a :meth:`.Session.query`, each</span>
<span class="sd">        individual INSERT/UPDATE/DELETE operation within a</span>
<span class="sd">        :meth:`.Session.flush`, call, etc.</span>

<span class="sd">        The order of resolution is:</span>

<span class="sd">        1. if mapper given and :paramref:`.Session.binds` is present,</span>
<span class="sd">           locate a bind based first on the mapper in use, then</span>
<span class="sd">           on the mapped class in use, then on any base classes that are</span>
<span class="sd">           present in the ``__mro__`` of the mapped class, from more specific</span>
<span class="sd">           superclasses to more general.</span>
<span class="sd">        2. if clause given and ``Session.binds`` is present,</span>
<span class="sd">           locate a bind based on :class:`_schema.Table` objects</span>
<span class="sd">           found in the given clause present in ``Session.binds``.</span>
<span class="sd">        3. if ``Session.binds`` is present, return that.</span>
<span class="sd">        4. if clause given, attempt to return a bind</span>
<span class="sd">           linked to the :class:`_schema.MetaData` ultimately</span>
<span class="sd">           associated with the clause.</span>
<span class="sd">        5. if mapper given, attempt to return a bind</span>
<span class="sd">           linked to the :class:`_schema.MetaData` ultimately</span>
<span class="sd">           associated with the :class:`_schema.Table` or other</span>
<span class="sd">           selectable to which the mapper is mapped.</span>
<span class="sd">        6. No bind can be found, :exc:`~sqlalchemy.exc.UnboundExecutionError`</span>
<span class="sd">           is raised.</span>

<span class="sd">        Note that the :meth:`.Session.get_bind` method can be overridden on</span>
<span class="sd">        a user-defined subclass of :class:`.Session` to provide any kind</span>
<span class="sd">        of bind resolution scheme.  See the example at</span>
<span class="sd">        :ref:`session_custom_partitioning`.</span>

<span class="sd">        :param mapper:</span>
<span class="sd">          Optional mapped class or corresponding :class:`_orm.Mapper` instance.</span>
<span class="sd">          The bind can be derived from a :class:`_orm.Mapper` first by</span>
<span class="sd">          consulting the &quot;binds&quot; map associated with this :class:`.Session`,</span>
<span class="sd">          and secondly by consulting the :class:`_schema.MetaData` associated</span>
<span class="sd">          with the :class:`_schema.Table` to which the :class:`_orm.Mapper` is</span>
<span class="sd">          mapped for a bind.</span>

<span class="sd">        :param clause:</span>
<span class="sd">            A :class:`_expression.ClauseElement` (i.e.</span>
<span class="sd">            :func:`_expression.select`,</span>
<span class="sd">            :func:`_expression.text`,</span>
<span class="sd">            etc.).  If the ``mapper`` argument is not present or could not</span>
<span class="sd">            produce a bind, the given expression construct will be searched</span>
<span class="sd">            for a bound element, typically a :class:`_schema.Table`</span>
<span class="sd">            associated with</span>
<span class="sd">            bound :class:`_schema.MetaData`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">             :ref:`session_partitioning`</span>

<span class="sd">             :paramref:`.Session.binds`</span>

<span class="sd">             :meth:`.Session.bind_mapper`</span>

<span class="sd">             :meth:`.Session.bind_table`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># this function is documented as a subclassing hook, so we have</span>
        <span class="c1"># to call this method even if the return is simple</span>
        <span class="k">if</span> <span class="n">bind</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bind</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
            <span class="c1"># simplest and most common case, we have a bind and no</span>
            <span class="c1"># per-mapper/table binds, we&#39;re done</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span>

        <span class="c1"># we don&#39;t have self.bind and either have self.__binds</span>
        <span class="c1"># or we don&#39;t have self.__binds (which is legacy).  Look at the</span>
        <span class="c1"># mapper and the clause</span>
        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">clause</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">UnboundExecutionError</span><span class="p">(</span>
                    <span class="s2">&quot;This session is not bound to a single Engine or &quot;</span>
                    <span class="s2">&quot;Connection, and no context was provided to locate &quot;</span>
                    <span class="s2">&quot;a binding.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># look more closely at the mapper.</span>
        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">inspected_mapper</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">NoInspectionAvailable</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedClassError</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inspected_mapper</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># match up the mapper or clause in the __binds</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">:</span>
            <span class="c1"># matching mappers and selectables to entries in the</span>
            <span class="c1"># binds dictionary; supported use case.</span>
            <span class="k">if</span> <span class="n">inspected_mapper</span><span class="p">:</span>
                <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">inspected_mapper</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">clause</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">clause</span> <span class="o">=</span> <span class="n">inspected_mapper</span><span class="o">.</span><span class="n">persist_selectable</span>

            <span class="k">if</span> <span class="n">clause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plugin_subject</span> <span class="o">=</span> <span class="n">clause</span><span class="o">.</span><span class="n">_propagate_attrs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="s2">&quot;plugin_subject&quot;</span><span class="p">,</span> <span class="kc">None</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">plugin_subject</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">plugin_subject</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="vm">__mro__</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">:</span>
                            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="bp">cls</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">visitors</span><span class="o">.</span><span class="n">iterate</span><span class="p">(</span><span class="n">clause</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
                            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Table</span><span class="p">)</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>

        <span class="c1"># none of the __binds matched, but we have a fallback bind.</span>
        <span class="c1"># return that</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span>

        <span class="n">context</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">inspected_mapper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mapper </span><span class="si">{</span><span class="n">inspected_mapper</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;SQL expression&quot;</span><span class="p">)</span>

        <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">UnboundExecutionError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Could not locate a bind configured on &quot;</span>
            <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">context</span><span class="p">)</span><span class="si">}</span><span class="s1"> or this Session.&#39;</span>
        <span class="p">)</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_entity</span><span class="p">:</span> <span class="n">_EntityType</span><span class="p">[</span><span class="n">_O</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Query</span><span class="p">[</span><span class="n">_O</span><span class="p">]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">_colexpr</span><span class="p">:</span> <span class="n">TypedColumnsClauseRole</span><span class="p">[</span><span class="n">_T</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RowReturningQuery</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_T</span><span class="p">]]:</span> <span class="o">...</span>

    <span class="c1"># START OVERLOADED FUNCTIONS self.query RowReturningQuery 2-8</span>

    <span class="c1"># code within this block is **programmatically,</span>
    <span class="c1"># statically generated** by tools/generate_tuple_map_overloads.py</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">__ent0</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T0</span><span class="p">],</span> <span class="n">__ent1</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T1</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RowReturningQuery</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_T0</span><span class="p">,</span> <span class="n">_T1</span><span class="p">]]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">__ent0</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T0</span><span class="p">],</span> <span class="n">__ent1</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T1</span><span class="p">],</span> <span class="n">__ent2</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T2</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RowReturningQuery</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_T0</span><span class="p">,</span> <span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="p">]]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">__ent0</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T0</span><span class="p">],</span>
        <span class="n">__ent1</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T1</span><span class="p">],</span>
        <span class="n">__ent2</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T2</span><span class="p">],</span>
        <span class="n">__ent3</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T3</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RowReturningQuery</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_T0</span><span class="p">,</span> <span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="p">,</span> <span class="n">_T3</span><span class="p">]]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">__ent0</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T0</span><span class="p">],</span>
        <span class="n">__ent1</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T1</span><span class="p">],</span>
        <span class="n">__ent2</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T2</span><span class="p">],</span>
        <span class="n">__ent3</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T3</span><span class="p">],</span>
        <span class="n">__ent4</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T4</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RowReturningQuery</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_T0</span><span class="p">,</span> <span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="p">,</span> <span class="n">_T3</span><span class="p">,</span> <span class="n">_T4</span><span class="p">]]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">__ent0</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T0</span><span class="p">],</span>
        <span class="n">__ent1</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T1</span><span class="p">],</span>
        <span class="n">__ent2</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T2</span><span class="p">],</span>
        <span class="n">__ent3</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T3</span><span class="p">],</span>
        <span class="n">__ent4</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T4</span><span class="p">],</span>
        <span class="n">__ent5</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T5</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RowReturningQuery</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_T0</span><span class="p">,</span> <span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="p">,</span> <span class="n">_T3</span><span class="p">,</span> <span class="n">_T4</span><span class="p">,</span> <span class="n">_T5</span><span class="p">]]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">__ent0</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T0</span><span class="p">],</span>
        <span class="n">__ent1</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T1</span><span class="p">],</span>
        <span class="n">__ent2</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T2</span><span class="p">],</span>
        <span class="n">__ent3</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T3</span><span class="p">],</span>
        <span class="n">__ent4</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T4</span><span class="p">],</span>
        <span class="n">__ent5</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T5</span><span class="p">],</span>
        <span class="n">__ent6</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T6</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RowReturningQuery</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_T0</span><span class="p">,</span> <span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="p">,</span> <span class="n">_T3</span><span class="p">,</span> <span class="n">_T4</span><span class="p">,</span> <span class="n">_T5</span><span class="p">,</span> <span class="n">_T6</span><span class="p">]]:</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">__ent0</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T0</span><span class="p">],</span>
        <span class="n">__ent1</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T1</span><span class="p">],</span>
        <span class="n">__ent2</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T2</span><span class="p">],</span>
        <span class="n">__ent3</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T3</span><span class="p">],</span>
        <span class="n">__ent4</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T4</span><span class="p">],</span>
        <span class="n">__ent5</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T5</span><span class="p">],</span>
        <span class="n">__ent6</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T6</span><span class="p">],</span>
        <span class="n">__ent7</span><span class="p">:</span> <span class="n">_TCCA</span><span class="p">[</span><span class="n">_T7</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">RowReturningQuery</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">_T0</span><span class="p">,</span> <span class="n">_T1</span><span class="p">,</span> <span class="n">_T2</span><span class="p">,</span> <span class="n">_T3</span><span class="p">,</span> <span class="n">_T4</span><span class="p">,</span> <span class="n">_T5</span><span class="p">,</span> <span class="n">_T6</span><span class="p">,</span> <span class="n">_T7</span><span class="p">]]:</span> <span class="o">...</span>

    <span class="c1"># END OVERLOADED FUNCTIONS self.query</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">entities</span><span class="p">:</span> <span class="n">_ColumnsClauseArgument</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Query</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span> <span class="o">...</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">entities</span><span class="p">:</span> <span class="n">_ColumnsClauseArgument</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Query</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new :class:`_query.Query` object corresponding to this</span>
<span class="sd">        :class:`_orm.Session`.</span>

<span class="sd">        Note that the :class:`_query.Query` object is legacy as of</span>
<span class="sd">        SQLAlchemy 2.0; the :func:`_sql.select` construct is now used</span>
<span class="sd">        to construct ORM queries.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`unified_tutorial`</span>

<span class="sd">            :ref:`queryguide_toplevel`</span>

<span class="sd">            :ref:`query_api_toplevel` - legacy API doc</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_cls</span><span class="p">(</span><span class="n">entities</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_identity_lookup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Mapper</span><span class="p">[</span><span class="n">_O</span><span class="p">],</span>
        <span class="n">primary_key_identity</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]],</span>
        <span class="n">identity_token</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">passive</span><span class="p">:</span> <span class="n">PassiveFlag</span> <span class="o">=</span> <span class="n">PassiveFlag</span><span class="o">.</span><span class="n">PASSIVE_OFF</span><span class="p">,</span>
        <span class="n">lazy_loaded_from</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">_O</span><span class="p">],</span> <span class="n">LoaderCallableStatus</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Locate an object in the identity map.</span>

<span class="sd">        Given a primary key identity, constructs an identity key and then</span>
<span class="sd">        looks in the session&#39;s identity map.  If present, the object may</span>
<span class="sd">        be run through unexpiration rules (e.g. load unloaded attributes,</span>
<span class="sd">        check if was deleted).</span>

<span class="sd">        e.g.::</span>

<span class="sd">            obj = session._identity_lookup(inspect(SomeClass), (1, ))</span>

<span class="sd">        :param mapper: mapper in use</span>
<span class="sd">        :param primary_key_identity: the primary key we are searching for, as</span>
<span class="sd">         a tuple.</span>
<span class="sd">        :param identity_token: identity token that should be used to create</span>
<span class="sd">         the identity key.  Used as is, however overriding subclasses can</span>
<span class="sd">         repurpose this in order to interpret the value in a special way,</span>
<span class="sd">         such as if None then look among multiple target tokens.</span>
<span class="sd">        :param passive: passive load flag passed to</span>
<span class="sd">         :func:`.loading.get_from_identity`, which impacts the behavior if</span>
<span class="sd">         the object is found; the object may be validated and/or unexpired</span>
<span class="sd">         if the flag allows for SQL to be emitted.</span>
<span class="sd">        :param lazy_loaded_from: an :class:`.InstanceState` that is</span>
<span class="sd">         specifically asking for this identity as a related identity.  Used</span>
<span class="sd">         for sharding schemes where there is a correspondence between an object</span>
<span class="sd">         and a related object being lazy-loaded (or otherwise</span>
<span class="sd">         relationship-loaded).</span>

<span class="sd">        :return: None if the object is not found in the identity map, *or*</span>
<span class="sd">         if the object was unexpired and found to have been deleted.</span>
<span class="sd">         if passive flags disallow SQL and the object is expired, returns</span>
<span class="sd">         PASSIVE_NO_RESULT.   In all other cases the instance is returned.</span>

<span class="sd">        .. versionchanged:: 1.4.0 - the :meth:`.Session._identity_lookup`</span>
<span class="sd">           method was moved from :class:`_query.Query` to</span>
<span class="sd">           :class:`.Session`, to avoid having to instantiate the</span>
<span class="sd">           :class:`_query.Query` object.</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">key</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">identity_key_from_primary_key</span><span class="p">(</span>
            <span class="n">primary_key_identity</span><span class="p">,</span> <span class="n">identity_token</span><span class="o">=</span><span class="n">identity_token</span>
        <span class="p">)</span>

        <span class="c1"># work around: https://github.com/python/typing/discussions/1143</span>
        <span class="n">return_value</span> <span class="o">=</span> <span class="n">loading</span><span class="o">.</span><span class="n">get_from_identity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">passive</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">return_value</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">non_memoized_property</span>
    <span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">no_autoflush</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Session</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a context manager that disables autoflush.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            with session.no_autoflush:</span>

<span class="sd">                some_object = SomeClass()</span>
<span class="sd">                session.add(some_object)</span>
<span class="sd">                # won&#39;t autoflush</span>
<span class="sd">                some_object.related_thing = session.query(SomeRelated).first()</span>

<span class="sd">        Operations that proceed within the ``with:`` block</span>
<span class="sd">        will not be subject to flushes occurring upon query</span>
<span class="sd">        access.  This is useful when initializing a series</span>
<span class="sd">        of objects which involve existing database queries,</span>
<span class="sd">        where the uncompleted object should not yet be flushed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">autoflush</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="n">autoflush</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">langhelpers</span><span class="o">.</span><span class="n">tag_method_for_warnings</span><span class="p">(</span>
        <span class="s2">&quot;This warning originated from the Session &#39;autoflush&#39; process, &quot;</span>
        <span class="s2">&quot;which was invoked automatically in response to a user-initiated &quot;</span>
        <span class="s2">&quot;operation.&quot;</span><span class="p">,</span>
        <span class="n">sa_exc</span><span class="o">.</span><span class="n">SAWarning</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">_autoflush</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">StatementError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># note we are reraising StatementError as opposed to</span>
                <span class="c1"># raising FlushError with &quot;chaining&quot; to remain compatible</span>
                <span class="c1"># with code that catches StatementError, IntegrityError,</span>
                <span class="c1"># etc.</span>
                <span class="n">e</span><span class="o">.</span><span class="n">add_detail</span><span class="p">(</span>
                    <span class="s2">&quot;raised as a result of Query-invoked autoflush; &quot;</span>
                    <span class="s2">&quot;consider using a session.no_autoflush block if this &quot;</span>
                    <span class="s2">&quot;flush is occurring prematurely&quot;</span>
                <span class="p">)</span>
                <span class="k">raise</span> <span class="n">e</span><span class="o">.</span><span class="n">with_traceback</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">2</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span>
        <span class="n">attribute_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">with_for_update</span><span class="p">:</span> <span class="n">ForUpdateParameter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expire and refresh attributes on the given instance.</span>

<span class="sd">        The selected attributes will first be expired as they would when using</span>
<span class="sd">        :meth:`_orm.Session.expire`; then a SELECT statement will be issued to</span>
<span class="sd">        the database to refresh column-oriented attributes with the current</span>
<span class="sd">        value available in the current transaction.</span>

<span class="sd">        :func:`_orm.relationship` oriented attributes will also be immediately</span>
<span class="sd">        loaded if they were already eagerly loaded on the object, using the</span>
<span class="sd">        same eager loading strategy that they were loaded with originally.</span>

<span class="sd">        .. versionadded:: 1.4 - the :meth:`_orm.Session.refresh` method</span>
<span class="sd">           can also refresh eagerly loaded attributes.</span>

<span class="sd">        :func:`_orm.relationship` oriented attributes that would normally</span>
<span class="sd">        load using the ``select`` (or &quot;lazy&quot;) loader strategy will also</span>
<span class="sd">        load **if they are named explicitly in the attribute_names</span>
<span class="sd">        collection**, emitting a SELECT statement for the attribute using the</span>
<span class="sd">        ``immediate`` loader strategy.  If lazy-loaded relationships are not</span>
<span class="sd">        named in :paramref:`_orm.Session.refresh.attribute_names`, then</span>
<span class="sd">        they remain as &quot;lazy loaded&quot; attributes and are not implicitly</span>
<span class="sd">        refreshed.</span>

<span class="sd">        .. versionchanged:: 2.0.4  The :meth:`_orm.Session.refresh` method</span>
<span class="sd">           will now refresh lazy-loaded :func:`_orm.relationship` oriented</span>
<span class="sd">           attributes for those which are named explicitly in the</span>
<span class="sd">           :paramref:`_orm.Session.refresh.attribute_names` collection.</span>

<span class="sd">        .. tip::</span>

<span class="sd">            While the :meth:`_orm.Session.refresh` method is capable of</span>
<span class="sd">            refreshing both column and relationship oriented attributes, its</span>
<span class="sd">            primary focus is on refreshing of local column-oriented attributes</span>
<span class="sd">            on a single instance. For more open ended &quot;refresh&quot; functionality,</span>
<span class="sd">            including the ability to refresh the attributes on many objects at</span>
<span class="sd">            once while having explicit control over relationship loader</span>
<span class="sd">            strategies, use the</span>
<span class="sd">            :ref:`populate existing &lt;orm_queryguide_populate_existing&gt;` feature</span>
<span class="sd">            instead.</span>

<span class="sd">        Note that a highly isolated transaction will return the same values as</span>
<span class="sd">        were previously read in that same transaction, regardless of changes</span>
<span class="sd">        in database state outside of that transaction.   Refreshing</span>
<span class="sd">        attributes usually only makes sense at the start of a transaction</span>
<span class="sd">        where database rows have not yet been accessed.</span>

<span class="sd">        :param attribute_names: optional.  An iterable collection of</span>
<span class="sd">          string attribute names indicating a subset of attributes to</span>
<span class="sd">          be refreshed.</span>

<span class="sd">        :param with_for_update: optional boolean ``True`` indicating FOR UPDATE</span>
<span class="sd">          should be used, or may be a dictionary containing flags to</span>
<span class="sd">          indicate a more specific set of FOR UPDATE flags for the SELECT;</span>
<span class="sd">          flags should match the parameters of</span>
<span class="sd">          :meth:`_query.Query.with_for_update`.</span>
<span class="sd">          Supersedes the :paramref:`.Session.refresh.lockmode` parameter.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_expire` - introductory material</span>

<span class="sd">            :meth:`.Session.expire`</span>

<span class="sd">            :meth:`.Session.expire_all`</span>

<span class="sd">            :ref:`orm_queryguide_populate_existing` - allows any ORM query</span>
<span class="sd">            to refresh objects as they would be loaded normally.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_expire_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">)</span>

        <span class="c1"># this autoflush previously used to occur as a secondary effect</span>
        <span class="c1"># of the load_on_ident below.   Meaning we&#39;d organize the SELECT</span>
        <span class="c1"># based on current DB pks, then flush, then if pks changed in that</span>
        <span class="c1"># flush, crash.  this was unticketed but discovered as part of</span>
        <span class="c1"># #8703.  So here, autoflush up front, dont autoflush inside</span>
        <span class="c1"># load_on_ident.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_autoflush</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">with_for_update</span> <span class="o">==</span> <span class="p">{}:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">&quot;with_for_update should be the boolean value &quot;</span>
                <span class="s2">&quot;True, or a dictionary with options.  &quot;</span>
                <span class="s2">&quot;A blank dictionary is ambiguous.&quot;</span>
            <span class="p">)</span>

        <span class="n">with_for_update</span> <span class="o">=</span> <span class="n">ForUpdateArg</span><span class="o">.</span><span class="n">_from_argument</span><span class="p">(</span><span class="n">with_for_update</span><span class="p">)</span>

        <span class="n">stmt</span><span class="p">:</span> <span class="n">Select</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">object_mapper</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">loading</span><span class="o">.</span><span class="n">load_on_ident</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span>
                <span class="n">stmt</span><span class="p">,</span>
                <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">,</span>
                <span class="n">refresh_state</span><span class="o">=</span><span class="n">state</span><span class="p">,</span>
                <span class="n">with_for_update</span><span class="o">=</span><span class="n">with_for_update</span><span class="p">,</span>
                <span class="n">only_load_props</span><span class="o">=</span><span class="n">attribute_names</span><span class="p">,</span>
                <span class="n">require_pk_cols</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="c1"># technically unnecessary as we just did autoflush</span>
                <span class="c1"># above, however removes the additional unnecessary</span>
                <span class="c1"># call to _autoflush()</span>
                <span class="n">no_autoflush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">is_user_refresh</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Could not refresh instance &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">instance_str</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">expire_all</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expires all persistent instances within this Session.</span>

<span class="sd">        When any attributes on a persistent instance is next accessed,</span>
<span class="sd">        a query will be issued using the</span>
<span class="sd">        :class:`.Session` object&#39;s current transactional context in order to</span>
<span class="sd">        load all expired attributes for the given instance.   Note that</span>
<span class="sd">        a highly isolated transaction will return the same values as were</span>
<span class="sd">        previously read in that same transaction, regardless of changes</span>
<span class="sd">        in database state outside of that transaction.</span>

<span class="sd">        To expire individual objects and individual attributes</span>
<span class="sd">        on those objects, use :meth:`Session.expire`.</span>

<span class="sd">        The :class:`.Session` object&#39;s default behavior is to</span>
<span class="sd">        expire all state whenever the :meth:`Session.rollback`</span>
<span class="sd">        or :meth:`Session.commit` methods are called, so that new</span>
<span class="sd">        state can be loaded for the new transaction.   For this reason,</span>
<span class="sd">        calling :meth:`Session.expire_all` is not usually needed,</span>
<span class="sd">        assuming the transaction is isolated.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_expire` - introductory material</span>

<span class="sd">            :meth:`.Session.expire`</span>

<span class="sd">            :meth:`.Session.refresh`</span>

<span class="sd">            :meth:`_orm.Query.populate_existing`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">():</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expire</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expire the attributes on an instance.</span>

<span class="sd">        Marks the attributes of an instance as out of date. When an expired</span>
<span class="sd">        attribute is next accessed, a query will be issued to the</span>
<span class="sd">        :class:`.Session` object&#39;s current transactional context in order to</span>
<span class="sd">        load all expired attributes for the given instance.   Note that</span>
<span class="sd">        a highly isolated transaction will return the same values as were</span>
<span class="sd">        previously read in that same transaction, regardless of changes</span>
<span class="sd">        in database state outside of that transaction.</span>

<span class="sd">        To expire all objects in the :class:`.Session` simultaneously,</span>
<span class="sd">        use :meth:`Session.expire_all`.</span>

<span class="sd">        The :class:`.Session` object&#39;s default behavior is to</span>
<span class="sd">        expire all state whenever the :meth:`Session.rollback`</span>
<span class="sd">        or :meth:`Session.commit` methods are called, so that new</span>
<span class="sd">        state can be loaded for the new transaction.   For this reason,</span>
<span class="sd">        calling :meth:`Session.expire` only makes sense for the specific</span>
<span class="sd">        case that a non-ORM SQL statement was emitted in the current</span>
<span class="sd">        transaction.</span>

<span class="sd">        :param instance: The instance to be refreshed.</span>
<span class="sd">        :param attribute_names: optional list of string attribute names</span>
<span class="sd">          indicating a subset of attributes to be expired.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_expire` - introductory material</span>

<span class="sd">            :meth:`.Session.expire`</span>

<span class="sd">            :meth:`.Session.refresh`</span>

<span class="sd">            :meth:`_orm.Query.populate_existing`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expire_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expire_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
        <span class="n">attribute_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_persistent</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attribute_names</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_expire_attributes</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># pre-fetch the full cascade since the expire is going to</span>
            <span class="c1"># remove associations</span>
            <span class="n">cascaded</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span><span class="s2">&quot;refresh-expire&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_expire</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">cascaded</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_expire</span><span class="p">(</span><span class="n">st_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_conditional_expire</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">autoflush</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expire a state if persistent, else expunge if pending&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_detach</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expunge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove the `instance` from this ``Session``.</span>

<span class="sd">        This will free all internal references to the instance.  Cascading</span>
<span class="sd">        will be applied according to the *expunge* cascade rule.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Instance </span><span class="si">%s</span><span class="s2"> is not present in this Session&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">cascaded</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span><span class="s2">&quot;expunge&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expunge_states</span><span class="p">([</span><span class="n">state</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">st_</span> <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">cascaded</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_expunge_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span> <span class="n">to_transient</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="p">:</span>
                <span class="c1"># state is &quot;detached&quot; from being deleted, but still present</span>
                <span class="c1"># in the transaction snapshot</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_detach_states</span><span class="p">(</span>
            <span class="n">states</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">to_transient</span><span class="o">=</span><span class="n">to_transient</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_register_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Register all persistent objects from a flush.</span>

<span class="sd">        This is used both for pending objects moving to the persistent</span>
<span class="sd">        state as well as already persistent objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pending_to_persistent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">pending_to_persistent</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

            <span class="c1"># prevent against last minute dereferences of the object</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">instance_key</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_from_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">_none_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">instance_key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">mapper</span><span class="o">.</span><span class="n">allow_partial_pks</span>
                    <span class="ow">or</span> <span class="n">_none_set</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">instance_key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">FlushError</span><span class="p">(</span>
                        <span class="s2">&quot;Instance </span><span class="si">%s</span><span class="s2"> has a NULL identity key.  If this is an &quot;</span>
                        <span class="s2">&quot;auto-generated value, check that the database table &quot;</span>
                        <span class="s2">&quot;allows generation of new primary key values, and &quot;</span>
                        <span class="s2">&quot;that the mapped Column object is configured to &quot;</span>
                        <span class="s2">&quot;expect these generated values.  Ensure also that &quot;</span>
                        <span class="s2">&quot;this flush() is not occurring at an inappropriate &quot;</span>
                        <span class="s2">&quot;time, such as within a load() event.&quot;</span>
                        <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">instance_key</span>
                <span class="k">elif</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">!=</span> <span class="n">instance_key</span><span class="p">:</span>
                    <span class="c1"># primary key switch. use safe_discard() in case another</span>
                    <span class="c1"># state has already replaced this one in the identity</span>
                    <span class="c1"># map (see test/orm/test_naturalpks.py ReversePKsTest)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                    <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span>
                    <span class="k">assert</span> <span class="n">trans</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">trans</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">:</span>
                        <span class="n">orig_key</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">orig_key</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span>
                    <span class="n">trans</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">orig_key</span><span class="p">,</span>
                        <span class="n">instance_key</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">instance_key</span>

                <span class="c1"># there can be an existing state in the identity map</span>
                <span class="c1"># that is replaced when the primary keys of two instances</span>
                <span class="c1"># are swapped; see test/orm/test_naturalpks.py -&gt; test_reverse</span>
                <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">old</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                    <span class="ow">and</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_from_state</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="o">==</span> <span class="n">instance_key</span>
                    <span class="ow">and</span> <span class="n">old</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                <span class="p">):</span>
                    <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Identity map already had an identity for </span><span class="si">%s</span><span class="s2">, &quot;</span>
                        <span class="s2">&quot;replacing it with newly flushed object.   Are there &quot;</span>
                        <span class="s2">&quot;load operations occurring inside of an event handler &quot;</span>
                        <span class="s2">&quot;within the flush?&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">instance_key</span><span class="p">,)</span>
                    <span class="p">)</span>
                <span class="n">state</span><span class="o">.</span><span class="n">_orphaned_outside_of_session</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_commit_all_states</span><span class="p">(</span>
            <span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_register_altered</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pending_to_persistent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">):</span>
                <span class="n">pending_to_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="c1"># remove from new last, might be the last strong ref</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">states</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_register_altered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="o">.</span><span class="n">_new</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="o">.</span><span class="n">_dirty</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_remove_newly_deleted</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">persistent_to_deleted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">persistent_to_deleted</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="o">.</span><span class="n">_deleted</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">persistent_to_deleted</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># get a strong reference before we pop out of</span>
                <span class="c1"># self._deleted</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>  <span class="c1"># noqa</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># can&#39;t call state._detach() here, because this state</span>
            <span class="c1"># is still in the transaction snapshot and needs to be</span>
            <span class="c1"># tracked as part of that</span>
            <span class="k">if</span> <span class="n">persistent_to_deleted</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">persistent_to_deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">_warn</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Place an object into this :class:`_orm.Session`.</span>

<span class="sd">        Objects that are in the :term:`transient` state when passed to the</span>
<span class="sd">        :meth:`_orm.Session.add` method will move to the</span>
<span class="sd">        :term:`pending` state, until the next flush, at which point they</span>
<span class="sd">        will move to the :term:`persistent` state.</span>

<span class="sd">        Objects that are in the :term:`detached` state when passed to the</span>
<span class="sd">        :meth:`_orm.Session.add` method will move to the :term:`persistent`</span>
<span class="sd">        state directly.</span>

<span class="sd">        If the transaction used by the :class:`_orm.Session` is rolled back,</span>
<span class="sd">        objects which were transient when they were passed to</span>
<span class="sd">        :meth:`_orm.Session.add` will be moved back to the</span>
<span class="sd">        :term:`transient` state, and will no longer be present within this</span>
<span class="sd">        :class:`_orm.Session`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`_orm.Session.add_all`</span>

<span class="sd">            :ref:`session_adding` - at :ref:`session_basics`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_warn</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.add()&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instances</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">object</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add the given collection of instances to this :class:`_orm.Session`.</span>

<span class="sd">        See the documentation for :meth:`_orm.Session.add` for a general</span>
<span class="sd">        behavioral description.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`_orm.Session.add`</span>

<span class="sd">            :ref:`session_adding` - at :ref:`session_basics`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.add_all()&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">_warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_or_update_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">state</span><span class="o">.</span><span class="n">_orphaned_outside_of_session</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_impl</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span>
            <span class="s2">&quot;save-update&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">halt_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_contains_state</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_impl</span><span class="p">(</span><span class="n">st_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mark an instance as deleted.</span>

<span class="sd">        The object is assumed to be either :term:`persistent` or</span>
<span class="sd">        :term:`detached` when passed; after the method is called, the</span>
<span class="sd">        object will remain in the :term:`persistent` state until the next</span>
<span class="sd">        flush proceeds.  During this time, the object will also be a member</span>
<span class="sd">        of the :attr:`_orm.Session.deleted` collection.</span>

<span class="sd">        When the next flush proceeds, the object will move to the</span>
<span class="sd">        :term:`deleted` state, indicating a ``DELETE`` statement was emitted</span>
<span class="sd">        for its row within the current transaction.   When the transaction</span>
<span class="sd">        is successfully committed,</span>
<span class="sd">        the deleted object is moved to the :term:`detached` state and is</span>
<span class="sd">        no longer present within this :class:`_orm.Session`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_deleting` - at :ref:`session_basics`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.delete()&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_delete_impl</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">head</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_delete_impl</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">obj</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">head</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; is not persisted&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="n">to_attach</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">to_attach</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_after_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
            <span class="c1"># grab the cascades before adding the item to the deleted list</span>
            <span class="c1"># so that autoflush does not delete the item</span>
            <span class="c1"># the strong reference to the instance itself is significant here</span>
            <span class="n">cascade_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span><span class="s2">&quot;delete&quot;</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cascade_states</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>

        <span class="k">if</span> <span class="n">head</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">cascade_states</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">cascade_states</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_delete_impl</span><span class="p">(</span><span class="n">st_</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">entity</span><span class="p">:</span> <span class="n">_EntityBindKey</span><span class="p">[</span><span class="n">_O</span><span class="p">],</span>
        <span class="n">ident</span><span class="p">:</span> <span class="n">_PKIdentityArgument</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">ORMOption</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">populate_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">with_for_update</span><span class="p">:</span> <span class="n">ForUpdateParameter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">identity_token</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_O</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an instance based on the given primary key identifier,</span>
<span class="sd">        or ``None`` if not found.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            my_user = session.get(User, 5)</span>

<span class="sd">            some_object = session.get(VersionedFoo, (5, 10))</span>

<span class="sd">            some_object = session.get(</span>
<span class="sd">                VersionedFoo,</span>
<span class="sd">                {&quot;id&quot;: 5, &quot;version_id&quot;: 10}</span>
<span class="sd">            )</span>

<span class="sd">        .. versionadded:: 1.4 Added :meth:`_orm.Session.get`, which is moved</span>
<span class="sd">           from the now legacy :meth:`_orm.Query.get` method.</span>

<span class="sd">        :meth:`_orm.Session.get` is special in that it provides direct</span>
<span class="sd">        access to the identity map of the :class:`.Session`.</span>
<span class="sd">        If the given primary key identifier is present</span>
<span class="sd">        in the local identity map, the object is returned</span>
<span class="sd">        directly from this collection and no SQL is emitted,</span>
<span class="sd">        unless the object has been marked fully expired.</span>
<span class="sd">        If not present,</span>
<span class="sd">        a SELECT is performed in order to locate the object.</span>

<span class="sd">        :meth:`_orm.Session.get` also will perform a check if</span>
<span class="sd">        the object is present in the identity map and</span>
<span class="sd">        marked as expired - a SELECT</span>
<span class="sd">        is emitted to refresh the object as well as to</span>
<span class="sd">        ensure that the row is still present.</span>
<span class="sd">        If not, :class:`~sqlalchemy.orm.exc.ObjectDeletedError` is raised.</span>

<span class="sd">        :param entity: a mapped class or :class:`.Mapper` indicating the</span>
<span class="sd">         type of entity to be loaded.</span>

<span class="sd">        :param ident: A scalar, tuple, or dictionary representing the</span>
<span class="sd">         primary key.  For a composite (e.g. multiple column) primary key,</span>
<span class="sd">         a tuple or dictionary should be passed.</span>

<span class="sd">         For a single-column primary key, the scalar calling form is typically</span>
<span class="sd">         the most expedient.  If the primary key of a row is the value &quot;5&quot;,</span>
<span class="sd">         the call looks like::</span>

<span class="sd">            my_object = session.get(SomeClass, 5)</span>

<span class="sd">         The tuple form contains primary key values typically in</span>
<span class="sd">         the order in which they correspond to the mapped</span>
<span class="sd">         :class:`_schema.Table`</span>
<span class="sd">         object&#39;s primary key columns, or if the</span>
<span class="sd">         :paramref:`_orm.Mapper.primary_key` configuration parameter were</span>
<span class="sd">         used, in</span>
<span class="sd">         the order used for that parameter. For example, if the primary key</span>
<span class="sd">         of a row is represented by the integer</span>
<span class="sd">         digits &quot;5, 10&quot; the call would look like::</span>

<span class="sd">             my_object = session.get(SomeClass, (5, 10))</span>

<span class="sd">         The dictionary form should include as keys the mapped attribute names</span>
<span class="sd">         corresponding to each element of the primary key.  If the mapped class</span>
<span class="sd">         has the attributes ``id``, ``version_id`` as the attributes which</span>
<span class="sd">         store the object&#39;s primary key value, the call would look like::</span>

<span class="sd">            my_object = session.get(SomeClass, {&quot;id&quot;: 5, &quot;version_id&quot;: 10})</span>

<span class="sd">        :param options: optional sequence of loader options which will be</span>
<span class="sd">         applied to the query, if one is emitted.</span>

<span class="sd">        :param populate_existing: causes the method to unconditionally emit</span>
<span class="sd">         a SQL query and refresh the object with the newly loaded data,</span>
<span class="sd">         regardless of whether or not the object is already present.</span>

<span class="sd">        :param with_for_update: optional boolean ``True`` indicating FOR UPDATE</span>
<span class="sd">          should be used, or may be a dictionary containing flags to</span>
<span class="sd">          indicate a more specific set of FOR UPDATE flags for the SELECT;</span>
<span class="sd">          flags should match the parameters of</span>
<span class="sd">          :meth:`_query.Query.with_for_update`.</span>
<span class="sd">          Supersedes the :paramref:`.Session.refresh.lockmode` parameter.</span>

<span class="sd">        :param execution_options: optional dictionary of execution options,</span>
<span class="sd">         which will be associated with the query execution if one is emitted.</span>
<span class="sd">         This dictionary can provide a subset of the options that are</span>
<span class="sd">         accepted by :meth:`_engine.Connection.execution_options`, and may</span>
<span class="sd">         also provide additional options understood only in an ORM context.</span>

<span class="sd">         .. versionadded:: 1.4.29</span>

<span class="sd">         .. seealso::</span>

<span class="sd">            :ref:`orm_queryguide_execution_options` - ORM-specific execution</span>
<span class="sd">            options</span>

<span class="sd">        :param bind_arguments: dictionary of additional arguments to determine</span>
<span class="sd">         the bind.  May include &quot;mapper&quot;, &quot;bind&quot;, or other custom arguments.</span>
<span class="sd">         Contents of this dictionary are passed to the</span>
<span class="sd">         :meth:`.Session.get_bind` method.</span>

<span class="sd">         .. versionadded: 2.0.0rc1</span>

<span class="sd">        :return: The object instance, or ``None``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_impl</span><span class="p">(</span>
            <span class="n">entity</span><span class="p">,</span>
            <span class="n">ident</span><span class="p">,</span>
            <span class="n">loading</span><span class="o">.</span><span class="n">load_on_pk_identity</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
            <span class="n">populate_existing</span><span class="o">=</span><span class="n">populate_existing</span><span class="p">,</span>
            <span class="n">with_for_update</span><span class="o">=</span><span class="n">with_for_update</span><span class="p">,</span>
            <span class="n">identity_token</span><span class="o">=</span><span class="n">identity_token</span><span class="p">,</span>
            <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span><span class="p">,</span>
            <span class="n">bind_arguments</span><span class="o">=</span><span class="n">bind_arguments</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_one</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">entity</span><span class="p">:</span> <span class="n">_EntityBindKey</span><span class="p">[</span><span class="n">_O</span><span class="p">],</span>
        <span class="n">ident</span><span class="p">:</span> <span class="n">_PKIdentityArgument</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">ORMOption</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">populate_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">with_for_update</span><span class="p">:</span> <span class="n">ForUpdateParameter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">identity_token</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_O</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return exactly one instance based on the given primary key</span>
<span class="sd">        identifier, or raise an exception if not found.</span>

<span class="sd">        Raises ``sqlalchemy.orm.exc.NoResultFound`` if the query</span>
<span class="sd">        selects no rows.</span>

<span class="sd">        For a detailed documentation of the arguments see the</span>
<span class="sd">        method :meth:`.Session.get`.</span>

<span class="sd">        .. versionadded:: 2.0.22</span>

<span class="sd">        :return: The object instance.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`.Session.get` - equivalent method that instead</span>
<span class="sd">              returns ``None`` if no row was found with the provided primary</span>
<span class="sd">              key</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
            <span class="n">entity</span><span class="p">,</span>
            <span class="n">ident</span><span class="p">,</span>
            <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
            <span class="n">populate_existing</span><span class="o">=</span><span class="n">populate_existing</span><span class="p">,</span>
            <span class="n">with_for_update</span><span class="o">=</span><span class="n">with_for_update</span><span class="p">,</span>
            <span class="n">identity_token</span><span class="o">=</span><span class="n">identity_token</span><span class="p">,</span>
            <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span><span class="p">,</span>
            <span class="n">bind_arguments</span><span class="o">=</span><span class="n">bind_arguments</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">NoResultFound</span><span class="p">(</span>
                <span class="s2">&quot;No row was found when one was required&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">instance</span>

    <span class="k">def</span> <span class="nf">_get_impl</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">entity</span><span class="p">:</span> <span class="n">_EntityBindKey</span><span class="p">[</span><span class="n">_O</span><span class="p">],</span>
        <span class="n">primary_key_identity</span><span class="p">:</span> <span class="n">_PKIdentityArgument</span><span class="p">,</span>
        <span class="n">db_load_fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">_O</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">ExecutableOption</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">populate_existing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">with_for_update</span><span class="p">:</span> <span class="n">ForUpdateParameter</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">identity_token</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">execution_options</span><span class="p">:</span> <span class="n">OrmExecuteOptionsParameter</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">EMPTY_DICT</span><span class="p">,</span>
        <span class="n">bind_arguments</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_BindArguments</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_O</span><span class="p">]:</span>
        <span class="c1"># convert composite types to individual args</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">is_composite_class</span><span class="p">(</span><span class="n">primary_key_identity</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">primary_key_identity</span><span class="p">)</span>
            <span class="ow">in</span> <span class="n">descriptor_props</span><span class="o">.</span><span class="n">_composite_getters</span>
        <span class="p">):</span>
            <span class="n">getter</span> <span class="o">=</span> <span class="n">descriptor_props</span><span class="o">.</span><span class="n">_composite_getters</span><span class="p">[</span>
                <span class="nb">type</span><span class="p">(</span><span class="n">primary_key_identity</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">primary_key_identity</span> <span class="o">=</span> <span class="n">getter</span><span class="p">(</span><span class="n">primary_key_identity</span><span class="p">)</span>

        <span class="n">mapper</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapper</span><span class="p">[</span><span class="n">_O</span><span class="p">]]</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">entity</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mapper</span><span class="o">.</span><span class="n">is_mapper</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                <span class="s2">&quot;Expected mapped class or mapper, got: </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">entity</span>
            <span class="p">)</span>

        <span class="n">is_dict</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">primary_key_identity</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_dict</span><span class="p">:</span>
            <span class="n">primary_key_identity</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span>
                <span class="n">primary_key_identity</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">primary_key_identity</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mapper</span><span class="o">.</span><span class="n">primary_key</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Incorrect number of values in identifier to formulate &quot;</span>
                <span class="s2">&quot;primary key for session.get(); primary key columns &quot;</span>
                <span class="s2">&quot;are </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">primary_key</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">is_dict</span><span class="p">:</span>
            <span class="n">pk_synonyms</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_pk_synonyms</span>

            <span class="k">if</span> <span class="n">pk_synonyms</span><span class="p">:</span>
                <span class="n">correct_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pk_synonyms</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                    <span class="n">primary_key_identity</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="n">correct_keys</span><span class="p">:</span>
                    <span class="n">primary_key_identity</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">primary_key_identity</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">correct_keys</span><span class="p">:</span>
                        <span class="n">primary_key_identity</span><span class="p">[</span><span class="n">pk_synonyms</span><span class="p">[</span><span class="n">k</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">primary_key_identity</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">primary_key_identity</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="n">primary_key_identity</span><span class="p">[</span><span class="n">prop</span><span class="o">.</span><span class="n">key</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_props</span>
                <span class="p">)</span>

            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;Incorrect names of values in identifier to formulate &quot;</span>
                    <span class="s2">&quot;primary key for session.get(); primary key attribute &quot;</span>
                    <span class="s2">&quot;names are </span><span class="si">%s</span><span class="s2"> (synonym names are also accepted)&quot;</span>
                    <span class="o">%</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">prop</span><span class="o">.</span><span class="n">key</span>
                        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_props</span>
                    <span class="p">)</span>
                <span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">populate_existing</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="n">mapper</span><span class="o">.</span><span class="n">always_refresh</span>
            <span class="ow">and</span> <span class="n">with_for_update</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identity_lookup</span><span class="p">(</span>
                <span class="n">mapper</span><span class="p">,</span>
                <span class="n">primary_key_identity</span><span class="p">,</span>
                <span class="n">identity_token</span><span class="o">=</span><span class="n">identity_token</span><span class="p">,</span>
                <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span><span class="p">,</span>
                <span class="n">bind_arguments</span><span class="o">=</span><span class="n">bind_arguments</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># reject calls for id in identity map but class</span>
                <span class="c1"># mismatch.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="p">):</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">return</span> <span class="n">instance</span>

            <span class="c1"># TODO: this was being tested before, but this is not possible</span>
            <span class="k">assert</span> <span class="n">instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">LoaderCallableStatus</span><span class="o">.</span><span class="n">PASSIVE_CLASS_MISMATCH</span>

        <span class="c1"># set_label_style() not strictly necessary, however this will ensure</span>
        <span class="c1"># that tablename_colname style is used which at the moment is</span>
        <span class="c1"># asserted in a lot of unit tests :)</span>

        <span class="n">load_options</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">QueryContext</span><span class="o">.</span><span class="n">default_load_options</span>

        <span class="k">if</span> <span class="n">populate_existing</span><span class="p">:</span>
            <span class="n">load_options</span> <span class="o">+=</span> <span class="p">{</span><span class="s2">&quot;_populate_existing&quot;</span><span class="p">:</span> <span class="n">populate_existing</span><span class="p">}</span>
        <span class="n">statement</span> <span class="o">=</span> <span class="n">sql</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span><span class="o">.</span><span class="n">set_label_style</span><span class="p">(</span>
            <span class="n">LABEL_STYLE_TABLENAME_PLUS_COL</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">with_for_update</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">statement</span><span class="o">.</span><span class="n">_for_update_arg</span> <span class="o">=</span> <span class="n">ForUpdateArg</span><span class="o">.</span><span class="n">_from_argument</span><span class="p">(</span>
                <span class="n">with_for_update</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">statement</span> <span class="o">=</span> <span class="n">statement</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="o">*</span><span class="n">options</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">db_load_fn</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">statement</span><span class="p">,</span>
            <span class="n">primary_key_identity</span><span class="p">,</span>
            <span class="n">load_options</span><span class="o">=</span><span class="n">load_options</span><span class="p">,</span>
            <span class="n">identity_token</span><span class="o">=</span><span class="n">identity_token</span><span class="p">,</span>
            <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span><span class="p">,</span>
            <span class="n">bind_arguments</span><span class="o">=</span><span class="n">bind_arguments</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">instance</span><span class="p">:</span> <span class="n">_O</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">load</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">ORMOption</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_O</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Copy the state of a given instance into a corresponding instance</span>
<span class="sd">        within this :class:`.Session`.</span>

<span class="sd">        :meth:`.Session.merge` examines the primary key attributes of the</span>
<span class="sd">        source instance, and attempts to reconcile it with an instance of the</span>
<span class="sd">        same primary key in the session.   If not found locally, it attempts</span>
<span class="sd">        to load the object from the database based on primary key, and if</span>
<span class="sd">        none can be located, creates a new instance.  The state of each</span>
<span class="sd">        attribute on the source instance is then copied to the target</span>
<span class="sd">        instance.  The resulting target instance is then returned by the</span>
<span class="sd">        method; the original source instance is left unmodified, and</span>
<span class="sd">        un-associated with the :class:`.Session` if not already.</span>

<span class="sd">        This operation cascades to associated instances if the association is</span>
<span class="sd">        mapped with ``cascade=&quot;merge&quot;``.</span>

<span class="sd">        See :ref:`unitofwork_merging` for a detailed discussion of merging.</span>

<span class="sd">        :param instance: Instance to be merged.</span>
<span class="sd">        :param load: Boolean, when False, :meth:`.merge` switches into</span>
<span class="sd">         a &quot;high performance&quot; mode which causes it to forego emitting history</span>
<span class="sd">         events as well as all database access.  This flag is used for</span>
<span class="sd">         cases such as transferring graphs of objects into a :class:`.Session`</span>
<span class="sd">         from a second level cache, or to transfer just-loaded objects</span>
<span class="sd">         into the :class:`.Session` owned by a worker thread or process</span>
<span class="sd">         without re-querying the database.</span>

<span class="sd">         The ``load=False`` use case adds the caveat that the given</span>
<span class="sd">         object has to be in a &quot;clean&quot; state, that is, has no pending changes</span>
<span class="sd">         to be flushed - even if the incoming object is detached from any</span>
<span class="sd">         :class:`.Session`.   This is so that when</span>
<span class="sd">         the merge operation populates local attributes and</span>
<span class="sd">         cascades to related objects and</span>
<span class="sd">         collections, the values can be &quot;stamped&quot; onto the</span>
<span class="sd">         target object as is, without generating any history or attribute</span>
<span class="sd">         events, and without the need to reconcile the incoming data with</span>
<span class="sd">         any existing related objects or collections that might not</span>
<span class="sd">         be loaded.  The resulting objects from ``load=False`` are always</span>
<span class="sd">         produced as &quot;clean&quot;, so it is only appropriate that the given objects</span>
<span class="sd">         should be &quot;clean&quot; as well, else this suggests a mis-use of the</span>
<span class="sd">         method.</span>
<span class="sd">        :param options: optional sequence of loader options which will be</span>
<span class="sd">         applied to the :meth:`_orm.Session.get` method when the merge</span>
<span class="sd">         operation loads the existing version of the object from the database.</span>

<span class="sd">         .. versionadded:: 1.4.24</span>


<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`.make_transient_to_detached` - provides for an alternative</span>
<span class="sd">            means of &quot;merging&quot; a single object into the :class:`.Session`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.merge()&quot;</span><span class="p">)</span>

        <span class="n">_recursive</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">_resolve_conflict_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">_IdentityKeyType</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">load</span><span class="p">:</span>
            <span class="c1"># flush current contents if we expect to load data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_autoflush</span><span class="p">()</span>

        <span class="n">object_mapper</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>  <span class="c1"># verify mapped</span>
        <span class="n">autoflush</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge</span><span class="p">(</span>
                <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span>
                <span class="n">attributes</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span>
                <span class="n">load</span><span class="o">=</span><span class="n">load</span><span class="p">,</span>
                <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
                <span class="n">_recursive</span><span class="o">=</span><span class="n">_recursive</span><span class="p">,</span>
                <span class="n">_resolve_conflict_map</span><span class="o">=</span><span class="n">_resolve_conflict_map</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="n">autoflush</span>

    <span class="k">def</span> <span class="nf">_merge</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">_O</span><span class="p">],</span>
        <span class="n">state_dict</span><span class="p">:</span> <span class="n">_InstanceDict</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">ORMOption</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">load</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">_recursive</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="nb">object</span><span class="p">],</span>
        <span class="n">_resolve_conflict_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">_IdentityKeyType</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="nb">object</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_O</span><span class="p">:</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Mapper</span><span class="p">[</span><span class="n">_O</span><span class="p">]</span> <span class="o">=</span> <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">_recursive</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">_O</span><span class="p">,</span> <span class="n">_recursive</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>

        <span class="n">new_instance</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span>

        <span class="n">merged</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_O</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Instance </span><span class="si">%s</span><span class="s2"> is already pending in this Session yet is &quot;</span>
                    <span class="s2">&quot;being merged again; this is probably not what you want &quot;</span>
                    <span class="s2">&quot;to do&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">load</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;merge() with load=False option does not support &quot;</span>
                    <span class="s2">&quot;objects transient (i.e. unpersisted) objects.  flush() &quot;</span>
                    <span class="s2">&quot;all changes on mapped instances before merging with &quot;</span>
                    <span class="s2">&quot;load=False.&quot;</span>
                <span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_from_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">key_is_persistent</span> <span class="o">=</span> <span class="n">LoaderCallableStatus</span><span class="o">.</span><span class="n">NEVER_SET</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[</span>
                <span class="mi">1</span>
            <span class="p">]</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">_none_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="ow">or</span> <span class="p">(</span>
                    <span class="n">mapper</span><span class="o">.</span><span class="n">allow_partial_pks</span>
                    <span class="ow">and</span> <span class="ow">not</span> <span class="n">_none_set</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key_is_persistent</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="c1"># object was GC&#39;ed right as we checked for it</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">merged</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key_is_persistent</span> <span class="ow">and</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">_resolve_conflict_map</span><span class="p">:</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">_O</span><span class="p">,</span> <span class="n">_resolve_conflict_map</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

            <span class="k">elif</span> <span class="ow">not</span> <span class="n">load</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">modified</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                        <span class="s2">&quot;merge() with load=False option does not support &quot;</span>
                        <span class="s2">&quot;objects marked as &#39;dirty&#39;.  flush() all changes on &quot;</span>
                        <span class="s2">&quot;mapped instances before merging with load=False.&quot;</span>
                    <span class="p">)</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">class_manager</span><span class="o">.</span><span class="n">new_instance</span><span class="p">()</span>
                <span class="n">merged_state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
                <span class="n">merged_state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update_impl</span><span class="p">(</span><span class="n">merged_state</span><span class="p">)</span>
                <span class="n">new_instance</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">elif</span> <span class="n">key_is_persistent</span><span class="p">:</span>
                <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="p">,</span>
                    <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                    <span class="n">identity_token</span><span class="o">=</span><span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                    <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">merged</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">class_manager</span><span class="o">.</span><span class="n">new_instance</span><span class="p">()</span>
            <span class="n">merged_state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="n">merged_dict</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="n">new_instance</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_state</span><span class="p">(</span><span class="n">merged_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged_state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="n">merged_dict</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>

        <span class="n">_recursive</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span>
        <span class="n">_resolve_conflict_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span>

        <span class="c1"># check that we didn&#39;t just pull the exact same</span>
        <span class="c1"># state out.</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">merged_state</span><span class="p">:</span>
            <span class="c1"># version check if applicable</span>
            <span class="k">if</span> <span class="n">mapper</span><span class="o">.</span><span class="n">version_id_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">existing_version</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_get_state_attr_by_column</span><span class="p">(</span>
                    <span class="n">state</span><span class="p">,</span>
                    <span class="n">state_dict</span><span class="p">,</span>
                    <span class="n">mapper</span><span class="o">.</span><span class="n">version_id_col</span><span class="p">,</span>
                    <span class="n">passive</span><span class="o">=</span><span class="n">PassiveFlag</span><span class="o">.</span><span class="n">PASSIVE_NO_INITIALIZE</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="n">merged_version</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_get_state_attr_by_column</span><span class="p">(</span>
                    <span class="n">merged_state</span><span class="p">,</span>
                    <span class="n">merged_dict</span><span class="p">,</span>
                    <span class="n">mapper</span><span class="o">.</span><span class="n">version_id_col</span><span class="p">,</span>
                    <span class="n">passive</span><span class="o">=</span><span class="n">PassiveFlag</span><span class="o">.</span><span class="n">PASSIVE_NO_INITIALIZE</span><span class="p">,</span>
                <span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span>
                    <span class="n">existing_version</span>
                    <span class="ow">is</span> <span class="ow">not</span> <span class="n">LoaderCallableStatus</span><span class="o">.</span><span class="n">PASSIVE_NO_RESULT</span>
                    <span class="ow">and</span> <span class="n">merged_version</span>
                    <span class="ow">is</span> <span class="ow">not</span> <span class="n">LoaderCallableStatus</span><span class="o">.</span><span class="n">PASSIVE_NO_RESULT</span>
                    <span class="ow">and</span> <span class="n">existing_version</span> <span class="o">!=</span> <span class="n">merged_version</span>
                <span class="p">):</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">StaleDataError</span><span class="p">(</span>
                        <span class="s2">&quot;Version id &#39;</span><span class="si">%s</span><span class="s2">&#39; on merged state </span><span class="si">%s</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;does not match existing version &#39;</span><span class="si">%s</span><span class="s2">&#39;. &quot;</span>
                        <span class="s2">&quot;Leave the version attribute unset when &quot;</span>
                        <span class="s2">&quot;merging to update the most recent version.&quot;</span>
                        <span class="o">%</span> <span class="p">(</span>
                            <span class="n">existing_version</span><span class="p">,</span>
                            <span class="n">state_str</span><span class="p">(</span><span class="n">merged_state</span><span class="p">),</span>
                            <span class="n">merged_version</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

            <span class="n">merged_state</span><span class="o">.</span><span class="n">load_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">load_path</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">load_options</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">load_options</span>

            <span class="c1"># since we are copying load_options, we need to copy</span>
            <span class="c1"># the callables_ that would have been generated by those</span>
            <span class="c1"># load_options.</span>
            <span class="c1"># assumes that the callables we put in state.callables_</span>
            <span class="c1"># are not instance-specific (which they should not be)</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">_copy_callables</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">iterate_properties</span><span class="p">:</span>
                <span class="n">prop</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="bp">self</span><span class="p">,</span>
                    <span class="n">state</span><span class="p">,</span>
                    <span class="n">state_dict</span><span class="p">,</span>
                    <span class="n">merged_state</span><span class="p">,</span>
                    <span class="n">merged_dict</span><span class="p">,</span>
                    <span class="n">load</span><span class="p">,</span>
                    <span class="n">_recursive</span><span class="p">,</span>
                    <span class="n">_resolve_conflict_map</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">load</span><span class="p">:</span>
            <span class="c1"># remove any history</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">_commit_all</span><span class="p">(</span><span class="n">merged_dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">)</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">_sa_event_merge_wo_load</span><span class="p">(</span>
                <span class="n">merged_state</span><span class="p">,</span> <span class="kc">None</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">new_instance</span><span class="p">:</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">merged_state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">merged</span>

    <span class="k">def</span> <span class="nf">_validate_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; is not persistent within this Session&quot;</span>
                <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Object &#39;</span><span class="si">%s</span><span class="s2">&#39; already has an identity - &quot;</span>
                <span class="s2">&quot;it can&#39;t be registered as pending&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
        <span class="n">to_attach</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span>
            <span class="n">state</span><span class="o">.</span><span class="n">insert_order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">to_attach</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_after_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_impl</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">revert_deletion</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; is not persisted&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">revert_deletion</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">state</span><span class="o">.</span><span class="n">_attached</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; has been deleted.  &quot;</span>
                    <span class="s2">&quot;Use the make_transient() &quot;</span>
                    <span class="s2">&quot;function to send this object back &quot;</span>
                    <span class="s2">&quot;to the transient state.&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                <span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>

        <span class="c1"># check for late gc</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">to_attach</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">revert_deletion</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">to_attach</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_after_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">revert_deletion</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">deleted_to_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_or_update_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_impl</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_impl</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">enable_relationship_loading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Associate an object with this :class:`.Session` for related</span>
<span class="sd">        object loading.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            :meth:`.enable_relationship_loading` exists to serve special</span>
<span class="sd">            use cases and is not recommended for general use.</span>

<span class="sd">        Accesses of attributes mapped with :func:`_orm.relationship`</span>
<span class="sd">        will attempt to load a value from the database using this</span>
<span class="sd">        :class:`.Session` as the source of connectivity.  The values</span>
<span class="sd">        will be loaded based on foreign key and primary key values</span>
<span class="sd">        present on this object - if not present, then those relationships</span>
<span class="sd">        will be unavailable.</span>

<span class="sd">        The object will be attached to this session, but will</span>
<span class="sd">        **not** participate in any persistence operations; its state</span>
<span class="sd">        for almost all purposes will remain either &quot;transient&quot; or</span>
<span class="sd">        &quot;detached&quot;, except for the case of relationship loading.</span>

<span class="sd">        Also note that backrefs will often not work as expected.</span>
<span class="sd">        Altering a relationship-bound attribute on the target object</span>
<span class="sd">        may not fire off a backref event, if the effective value</span>
<span class="sd">        is what was already loaded from a foreign-key-holding value.</span>

<span class="sd">        The :meth:`.Session.enable_relationship_loading` method is</span>
<span class="sd">        similar to the ``load_on_pending`` flag on :func:`_orm.relationship`.</span>
<span class="sd">        Unlike that flag, :meth:`.Session.enable_relationship_loading` allows</span>
<span class="sd">        an object to remain transient while still being able to load</span>
<span class="sd">        related items.</span>

<span class="sd">        To make a transient object associated with a :class:`.Session`</span>
<span class="sd">        via :meth:`.Session.enable_relationship_loading` pending, add</span>
<span class="sd">        it to the :class:`.Session` using :meth:`.Session.add` normally.</span>
<span class="sd">        If the object instead represents an existing identity in the database,</span>
<span class="sd">        it should be merged using :meth:`.Session.merge`.</span>

<span class="sd">        :meth:`.Session.enable_relationship_loading` does not improve</span>
<span class="sd">        behavior when the ORM is used normally - object references should be</span>
<span class="sd">        constructed at the object level, not at the foreign key level, so</span>
<span class="sd">        that they are present in an ordinary way before flush()</span>
<span class="sd">        proceeds.  This method is not intended for general use.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :paramref:`_orm.relationship.load_on_pending` - this flag</span>
<span class="sd">            allows per-relationship loading of many-to-ones on items that</span>
<span class="sd">            are pending.</span>

<span class="sd">            :func:`.make_transient_to_detached` - allows for an object to</span>
<span class="sd">            be added to a :class:`.Session` without SQL emitted, which then</span>
<span class="sd">            will unexpire attributes on access.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>

        <span class="n">to_attach</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_before_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">_load_pending</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="n">to_attach</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_after_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_before_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">obj</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_autobegin_t</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">in</span> <span class="n">_sessions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Object &#39;</span><span class="si">%s</span><span class="s2">&#39; is already attached to session &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;(this is &#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">),</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_after_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">obj</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">modified</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">_strong_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_strong_obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">detached_to_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">transient_to_pending</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if the instance is associated with this session.</span>

<span class="sd">        The instance may be pending or persistent within the Session for a</span>
<span class="sd">        result of True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">object</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over all pending or persistent instances within this</span>
<span class="sd">        Session.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_contains_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objects</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flush all the object changes to the database.</span>

<span class="sd">        Writes out all pending object creations, deletions and modifications</span>
<span class="sd">        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are</span>
<span class="sd">        automatically ordered by the Session&#39;s unit of work dependency</span>
<span class="sd">        solver.</span>

<span class="sd">        Database operations will be issued in the current transactional</span>
<span class="sd">        context and do not affect the state of the transaction, unless an</span>
<span class="sd">        error occurs, in which case the entire transaction is rolled back.</span>
<span class="sd">        You may flush() as often as you like within a transaction to move</span>
<span class="sd">        changes from Python to the database&#39;s transaction buffer.</span>

<span class="sd">        :param objects: Optional; restricts the flush operation to operate</span>
<span class="sd">          only on elements that are in the given collection.</span>

<span class="sd">          This feature is for an extremely narrow set of use cases where</span>
<span class="sd">          particular objects may need to be operated upon before the</span>
<span class="sd">          full flush() occurs.  It is not intended for general use.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;Session is already flushing&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_clean</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_flush_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Usage of the &#39;</span><span class="si">%s</span><span class="s2">&#39; operation is not currently supported &quot;</span>
            <span class="s2">&quot;within the execution stage of the flush process. &quot;</span>
            <span class="s2">&quot;Results may not be consistent.  Consider using alternative &quot;</span>
            <span class="s2">&quot;event listeners or connection-level operations instead.&quot;</span> <span class="o">%</span> <span class="n">method</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_clean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">check_modified</span><span class="p">()</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objects</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">object</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dirty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_states</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dirty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">return</span>

        <span class="n">flush_context</span> <span class="o">=</span> <span class="n">UOWTransaction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_flush</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">,</span> <span class="n">objects</span><span class="p">)</span>
            <span class="c1"># re-establish &quot;dirty states&quot; in case the listeners</span>
            <span class="c1"># added</span>
            <span class="n">dirty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_states</span>

        <span class="n">deleted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>

        <span class="n">dirty</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dirty</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">deleted</span><span class="p">)</span>

        <span class="c1"># create the set of all objects we want to operate upon</span>
        <span class="k">if</span> <span class="n">objects</span><span class="p">:</span>
            <span class="c1"># specific list passed in</span>
            <span class="n">objset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

                <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
                <span class="n">objset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">objset</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># store objects whose fate has been decided</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># put all saves/updates into the flush context.  detect top-level</span>
        <span class="c1"># orphans and throw them into deleted.</span>
        <span class="k">if</span> <span class="n">objset</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">dirty</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">objset</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">deleted</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">dirty</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">deleted</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">proc</span><span class="p">:</span>
            <span class="n">is_orphan</span> <span class="o">=</span> <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">_is_orphan</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

            <span class="n">is_persistent_orphan</span> <span class="o">=</span> <span class="n">is_orphan</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">has_identity</span>

            <span class="k">if</span> <span class="p">(</span>
                <span class="n">is_orphan</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_persistent_orphan</span>
                <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">_orphaned_outside_of_session</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_expunge_states</span><span class="p">([</span><span class="n">state</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_reg</span> <span class="o">=</span> <span class="n">flush_context</span><span class="o">.</span><span class="n">register_object</span><span class="p">(</span>
                    <span class="n">state</span><span class="p">,</span> <span class="n">isdelete</span><span class="o">=</span><span class="n">is_persistent_orphan</span>
                <span class="p">)</span>
                <span class="k">assert</span> <span class="n">_reg</span><span class="p">,</span> <span class="s2">&quot;Failed to add object to the flush context!&quot;</span>
                <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="c1"># put all remaining deletes into the flush context.</span>
        <span class="k">if</span> <span class="n">objset</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">deleted</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">objset</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">deleted</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">proc</span><span class="p">:</span>
            <span class="n">_reg</span> <span class="o">=</span> <span class="n">flush_context</span><span class="o">.</span><span class="n">register_object</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">isdelete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">_reg</span><span class="p">,</span> <span class="s2">&quot;Failed to add object to the flush context!&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">flush_context</span><span class="o">.</span><span class="n">has_work</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">flush_context</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">transaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autobegin_t</span><span class="p">()</span><span class="o">.</span><span class="n">_begin</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">flush_context</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">)</span>

            <span class="n">flush_context</span><span class="o">.</span><span class="n">finalize_flush_changes</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">objects</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">:</span>
                <span class="n">len_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>

                <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_commit_all_states</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span>
                    <span class="p">],</span>
                    <span class="n">instance_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Attribute history events accumulated on </span><span class="si">%d</span><span class="s2"> &quot;</span>
                    <span class="s2">&quot;previously clean instances &quot;</span>
                    <span class="s2">&quot;within inner-flush event handlers have been &quot;</span>
                    <span class="s2">&quot;reset, and will not result in database updates. &quot;</span>
                    <span class="s2">&quot;Consider using set_committed_value() within &quot;</span>
                    <span class="s2">&quot;inner-flush event handlers to avoid this warning.&quot;</span> <span class="o">%</span> <span class="n">len_</span>
                <span class="p">)</span>

            <span class="c1"># useful assertions:</span>
            <span class="c1"># if not objects:</span>
            <span class="c1">#    assert not self.identity_map._modified</span>
            <span class="c1"># else:</span>
            <span class="c1">#    assert self.identity_map._modified == \</span>
            <span class="c1">#            self.identity_map._modified.difference(objects)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_flush_postexec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">)</span>

            <span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                <span class="n">transaction</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="n">_capture_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bulk_save_objects</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">objects</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">object</span><span class="p">],</span>
        <span class="n">return_defaults</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">update_changed_only</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">preserve_order</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a bulk save of the given list of objects.</span>

<span class="sd">        .. legacy::</span>

<span class="sd">            This method is a legacy feature as of the 2.0 series of</span>
<span class="sd">            SQLAlchemy.   For modern bulk INSERT and UPDATE, see</span>
<span class="sd">            the sections :ref:`orm_queryguide_bulk_insert` and</span>
<span class="sd">            :ref:`orm_queryguide_bulk_update`.</span>

<span class="sd">            For general INSERT and UPDATE of existing ORM mapped objects,</span>
<span class="sd">            prefer standard :term:`unit of work` data management patterns,</span>
<span class="sd">            introduced in the :ref:`unified_tutorial` at</span>
<span class="sd">            :ref:`tutorial_orm_data_manipulation`.  SQLAlchemy 2.0</span>
<span class="sd">            now uses :ref:`engine_insertmanyvalues` with modern dialects</span>
<span class="sd">            which solves previous issues of bulk INSERT slowness.</span>

<span class="sd">        :param objects: a sequence of mapped object instances.  The mapped</span>
<span class="sd">         objects are persisted as is, and are **not** associated with the</span>
<span class="sd">         :class:`.Session` afterwards.</span>

<span class="sd">         For each object, whether the object is sent as an INSERT or an</span>
<span class="sd">         UPDATE is dependent on the same rules used by the :class:`.Session`</span>
<span class="sd">         in traditional operation; if the object has the</span>
<span class="sd">         :attr:`.InstanceState.key`</span>
<span class="sd">         attribute set, then the object is assumed to be &quot;detached&quot; and</span>
<span class="sd">         will result in an UPDATE.  Otherwise, an INSERT is used.</span>

<span class="sd">         In the case of an UPDATE, statements are grouped based on which</span>
<span class="sd">         attributes have changed, and are thus to be the subject of each</span>
<span class="sd">         SET clause.  If ``update_changed_only`` is False, then all</span>
<span class="sd">         attributes present within each object are applied to the UPDATE</span>
<span class="sd">         statement, which may help in allowing the statements to be grouped</span>
<span class="sd">         together into a larger executemany(), and will also reduce the</span>
<span class="sd">         overhead of checking history on attributes.</span>

<span class="sd">        :param return_defaults: when True, rows that are missing values which</span>
<span class="sd">         generate defaults, namely integer primary key defaults and sequences,</span>
<span class="sd">         will be inserted **one at a time**, so that the primary key value</span>
<span class="sd">         is available.  In particular this will allow joined-inheritance</span>
<span class="sd">         and other multi-table mappings to insert correctly without the need</span>
<span class="sd">         to provide primary key values ahead of time; however,</span>
<span class="sd">         :paramref:`.Session.bulk_save_objects.return_defaults` **greatly</span>
<span class="sd">         reduces the performance gains** of the method overall.  It is strongly</span>
<span class="sd">         advised to please use the standard :meth:`_orm.Session.add_all`</span>
<span class="sd">         approach.</span>

<span class="sd">        :param update_changed_only: when True, UPDATE statements are rendered</span>
<span class="sd">         based on those attributes in each state that have logged changes.</span>
<span class="sd">         When False, all attributes present are rendered into the SET clause</span>
<span class="sd">         with the exception of primary key attributes.</span>

<span class="sd">        :param preserve_order: when True, the order of inserts and updates</span>
<span class="sd">         matches exactly the order in which the objects are given.   When</span>
<span class="sd">         False, common types of objects are grouped into inserts</span>
<span class="sd">         and updates, to allow for more batching opportunities.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :doc:`queryguide/dml`</span>

<span class="sd">            :meth:`.Session.bulk_insert_mappings`</span>

<span class="sd">            :meth:`.Session.bulk_update_mappings`</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">obj_states</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span>

        <span class="n">obj_states</span> <span class="o">=</span> <span class="p">(</span><span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">preserve_order</span><span class="p">:</span>
            <span class="c1"># the purpose of this sort is just so that common mappers</span>
            <span class="c1"># and persistence states are grouped together, so that groupby</span>
            <span class="c1"># will return a single group for a particular type of mapper.</span>
            <span class="c1"># it&#39;s not trying to be deterministic beyond that.</span>
            <span class="n">obj_states</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="n">obj_states</span><span class="p">,</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">state</span><span class="p">:</span> <span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">mapper</span><span class="p">),</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">def</span> <span class="nf">grouping_key</span><span class="p">(</span>
            <span class="n">state</span><span class="p">:</span> <span class="n">InstanceState</span><span class="p">[</span><span class="n">_O</span><span class="p">],</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Mapper</span><span class="p">[</span><span class="n">_O</span><span class="p">],</span> <span class="nb">bool</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">isupdate</span><span class="p">),</span> <span class="n">states</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="n">obj_states</span><span class="p">,</span> <span class="n">grouping_key</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bulk_save_mappings</span><span class="p">(</span>
                <span class="n">mapper</span><span class="p">,</span>
                <span class="n">states</span><span class="p">,</span>
                <span class="n">isupdate</span><span class="o">=</span><span class="n">isupdate</span><span class="p">,</span>
                <span class="n">isstates</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">return_defaults</span><span class="o">=</span><span class="n">return_defaults</span><span class="p">,</span>
                <span class="n">update_changed_only</span><span class="o">=</span><span class="n">update_changed_only</span><span class="p">,</span>
                <span class="n">render_nulls</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">bulk_insert_mappings</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Mapper</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
        <span class="n">mappings</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
        <span class="n">return_defaults</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">render_nulls</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a bulk insert of the given list of mapping dictionaries.</span>

<span class="sd">        .. legacy::</span>

<span class="sd">            This method is a legacy feature as of the 2.0 series of</span>
<span class="sd">            SQLAlchemy.   For modern bulk INSERT and UPDATE, see</span>
<span class="sd">            the sections :ref:`orm_queryguide_bulk_insert` and</span>
<span class="sd">            :ref:`orm_queryguide_bulk_update`.  The 2.0 API shares</span>
<span class="sd">            implementation details with this method and adds new features</span>
<span class="sd">            as well.</span>

<span class="sd">        :param mapper: a mapped class, or the actual :class:`_orm.Mapper`</span>
<span class="sd">         object,</span>
<span class="sd">         representing the single kind of object represented within the mapping</span>
<span class="sd">         list.</span>

<span class="sd">        :param mappings: a sequence of dictionaries, each one containing the</span>
<span class="sd">         state of the mapped row to be inserted, in terms of the attribute</span>
<span class="sd">         names on the mapped class.   If the mapping refers to multiple tables,</span>
<span class="sd">         such as a joined-inheritance mapping, each dictionary must contain all</span>
<span class="sd">         keys to be populated into all tables.</span>

<span class="sd">        :param return_defaults: when True, the INSERT process will be altered</span>
<span class="sd">         to ensure that newly generated primary key values will be fetched.</span>
<span class="sd">         The rationale for this parameter is typically to enable</span>
<span class="sd">         :ref:`Joined Table Inheritance &lt;joined_inheritance&gt;` mappings to</span>
<span class="sd">         be bulk inserted.</span>

<span class="sd">         .. note:: for backends that don&#39;t support RETURNING, the</span>
<span class="sd">            :paramref:`_orm.Session.bulk_insert_mappings.return_defaults`</span>
<span class="sd">            parameter can significantly decrease performance as INSERT</span>
<span class="sd">            statements can no longer be batched.   See</span>
<span class="sd">            :ref:`engine_insertmanyvalues`</span>
<span class="sd">            for background on which backends are affected.</span>

<span class="sd">        :param render_nulls: When True, a value of ``None`` will result</span>
<span class="sd">         in a NULL value being included in the INSERT statement, rather</span>
<span class="sd">         than the column being omitted from the INSERT.   This allows all</span>
<span class="sd">         the rows being INSERTed to have the identical set of columns which</span>
<span class="sd">         allows the full set of rows to be batched to the DBAPI.  Normally,</span>
<span class="sd">         each column-set that contains a different combination of NULL values</span>
<span class="sd">         than the previous row must omit a different series of columns from</span>
<span class="sd">         the rendered INSERT statement, which means it must be emitted as a</span>
<span class="sd">         separate statement.   By passing this flag, the full set of rows</span>
<span class="sd">         are guaranteed to be batchable into one batch; the cost however is</span>
<span class="sd">         that server-side defaults which are invoked by an omitted column will</span>
<span class="sd">         be skipped, so care must be taken to ensure that these are not</span>
<span class="sd">         necessary.</span>

<span class="sd">         .. warning::</span>

<span class="sd">            When this flag is set, **server side default SQL values will</span>
<span class="sd">            not be invoked** for those columns that are inserted as NULL;</span>
<span class="sd">            the NULL value will be sent explicitly.   Care must be taken</span>
<span class="sd">            to ensure that no server-side default functions need to be</span>
<span class="sd">            invoked for the operation as a whole.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :doc:`queryguide/dml`</span>

<span class="sd">            :meth:`.Session.bulk_save_objects`</span>

<span class="sd">            :meth:`.Session.bulk_update_mappings`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bulk_save_mappings</span><span class="p">(</span>
            <span class="n">mapper</span><span class="p">,</span>
            <span class="n">mappings</span><span class="p">,</span>
            <span class="n">isupdate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">isstates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">return_defaults</span><span class="o">=</span><span class="n">return_defaults</span><span class="p">,</span>
            <span class="n">update_changed_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">render_nulls</span><span class="o">=</span><span class="n">render_nulls</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">bulk_update_mappings</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">:</span> <span class="n">Mapper</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">mappings</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform a bulk update of the given list of mapping dictionaries.</span>

<span class="sd">        .. legacy::</span>

<span class="sd">            This method is a legacy feature as of the 2.0 series of</span>
<span class="sd">            SQLAlchemy.   For modern bulk INSERT and UPDATE, see</span>
<span class="sd">            the sections :ref:`orm_queryguide_bulk_insert` and</span>
<span class="sd">            :ref:`orm_queryguide_bulk_update`.  The 2.0 API shares</span>
<span class="sd">            implementation details with this method and adds new features</span>
<span class="sd">            as well.</span>

<span class="sd">        :param mapper: a mapped class, or the actual :class:`_orm.Mapper`</span>
<span class="sd">         object,</span>
<span class="sd">         representing the single kind of object represented within the mapping</span>
<span class="sd">         list.</span>

<span class="sd">        :param mappings: a sequence of dictionaries, each one containing the</span>
<span class="sd">         state of the mapped row to be updated, in terms of the attribute names</span>
<span class="sd">         on the mapped class.   If the mapping refers to multiple tables, such</span>
<span class="sd">         as a joined-inheritance mapping, each dictionary may contain keys</span>
<span class="sd">         corresponding to all tables.   All those keys which are present and</span>
<span class="sd">         are not part of the primary key are applied to the SET clause of the</span>
<span class="sd">         UPDATE statement; the primary key values, which are required, are</span>
<span class="sd">         applied to the WHERE clause.</span>


<span class="sd">        .. seealso::</span>

<span class="sd">            :doc:`queryguide/dml`</span>

<span class="sd">            :meth:`.Session.bulk_insert_mappings`</span>

<span class="sd">            :meth:`.Session.bulk_save_objects`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bulk_save_mappings</span><span class="p">(</span>
            <span class="n">mapper</span><span class="p">,</span>
            <span class="n">mappings</span><span class="p">,</span>
            <span class="n">isupdate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">isstates</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">return_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">update_changed_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">render_nulls</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bulk_save_mappings</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">mapper</span><span class="p">:</span> <span class="n">Mapper</span><span class="p">[</span><span class="n">_O</span><span class="p">],</span>
        <span class="n">mappings</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">_O</span><span class="p">]],</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">isupdate</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">isstates</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">return_defaults</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">update_changed_only</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
        <span class="n">render_nulls</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="n">_class_to_mapper</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">transaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autobegin_t</span><span class="p">()</span><span class="o">.</span><span class="n">_begin</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isupdate</span><span class="p">:</span>
                <span class="n">bulk_persistence</span><span class="o">.</span><span class="n">_bulk_update</span><span class="p">(</span>
                    <span class="n">mapper</span><span class="p">,</span>
                    <span class="n">mappings</span><span class="p">,</span>
                    <span class="n">transaction</span><span class="p">,</span>
                    <span class="n">isstates</span><span class="o">=</span><span class="n">isstates</span><span class="p">,</span>
                    <span class="n">update_changed_only</span><span class="o">=</span><span class="n">update_changed_only</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bulk_persistence</span><span class="o">.</span><span class="n">_bulk_insert</span><span class="p">(</span>
                    <span class="n">mapper</span><span class="p">,</span>
                    <span class="n">mappings</span><span class="p">,</span>
                    <span class="n">transaction</span><span class="p">,</span>
                    <span class="n">isstates</span><span class="o">=</span><span class="n">isstates</span><span class="p">,</span>
                    <span class="n">return_defaults</span><span class="o">=</span><span class="n">return_defaults</span><span class="p">,</span>
                    <span class="n">render_nulls</span><span class="o">=</span><span class="n">render_nulls</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                <span class="n">transaction</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="n">_capture_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_modified</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">include_collections</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return ``True`` if the given instance has locally</span>
<span class="sd">        modified attributes.</span>

<span class="sd">        This method retrieves the history for each instrumented</span>
<span class="sd">        attribute on the instance and performs a comparison of the current</span>
<span class="sd">        value to its previously flushed or committed value, if any.</span>

<span class="sd">        It is in effect a more expensive and accurate</span>
<span class="sd">        version of checking for the given instance in the</span>
<span class="sd">        :attr:`.Session.dirty` collection; a full test for</span>
<span class="sd">        each attribute&#39;s net &quot;dirty&quot; status is performed.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            return session.is_modified(someobject)</span>

<span class="sd">        A few caveats to this method apply:</span>

<span class="sd">        * Instances present in the :attr:`.Session.dirty` collection may</span>
<span class="sd">          report ``False`` when tested with this method.  This is because</span>
<span class="sd">          the object may have received change events via attribute mutation,</span>
<span class="sd">          thus placing it in :attr:`.Session.dirty`, but ultimately the state</span>
<span class="sd">          is the same as that loaded from the database, resulting in no net</span>
<span class="sd">          change here.</span>
<span class="sd">        * Scalar attributes may not have recorded the previously set</span>
<span class="sd">          value when a new value was applied, if the attribute was not loaded,</span>
<span class="sd">          or was expired, at the time the new value was received - in these</span>
<span class="sd">          cases, the attribute is assumed to have a change, even if there is</span>
<span class="sd">          ultimately no net change against its database value. SQLAlchemy in</span>
<span class="sd">          most cases does not need the &quot;old&quot; value when a set event occurs, so</span>
<span class="sd">          it skips the expense of a SQL call if the old value isn&#39;t present,</span>
<span class="sd">          based on the assumption that an UPDATE of the scalar value is</span>
<span class="sd">          usually needed, and in those few cases where it isn&#39;t, is less</span>
<span class="sd">          expensive on average than issuing a defensive SELECT.</span>

<span class="sd">          The &quot;old&quot; value is fetched unconditionally upon set only if the</span>
<span class="sd">          attribute container has the ``active_history`` flag set to ``True``.</span>
<span class="sd">          This flag is set typically for primary key attributes and scalar</span>
<span class="sd">          object references that are not a simple many-to-one.  To set this</span>
<span class="sd">          flag for any arbitrary mapped column, use the ``active_history``</span>
<span class="sd">          argument with :func:`.column_property`.</span>

<span class="sd">        :param instance: mapped instance to be tested for pending changes.</span>
<span class="sd">        :param include_collections: Indicates if multivalued collections</span>
<span class="sd">         should be included in the operation.  Setting this to ``False`` is a</span>
<span class="sd">         way to detect only local-column based properties (i.e. scalar columns</span>
<span class="sd">         or many-to-one foreign keys) that would result in an UPDATE for this</span>
<span class="sd">         instance upon flush.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">object_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">state</span><span class="o">.</span><span class="n">modified</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">dict_</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">dict</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="n">include_collections</span>
                <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span> <span class="s2">&quot;get_collection&quot;</span><span class="p">)</span>
            <span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span> <span class="s2">&quot;get_history&quot;</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">unchanged</span><span class="p">,</span> <span class="n">deleted</span><span class="p">)</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">impl</span><span class="o">.</span><span class="n">get_history</span><span class="p">(</span>
                <span class="n">state</span><span class="p">,</span> <span class="n">dict_</span><span class="p">,</span> <span class="n">passive</span><span class="o">=</span><span class="n">PassiveFlag</span><span class="o">.</span><span class="n">NO_CHANGE</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">added</span> <span class="ow">or</span> <span class="n">deleted</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_active</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if this :class:`.Session` not in &quot;partial rollback&quot; state.</span>

<span class="sd">        .. versionchanged:: 1.4 The :class:`_orm.Session` no longer begins</span>
<span class="sd">           a new transaction immediately, so this attribute will be False</span>
<span class="sd">           when the :class:`_orm.Session` is first instantiated.</span>

<span class="sd">        &quot;partial rollback&quot; state typically indicates that the flush process</span>
<span class="sd">        of the :class:`_orm.Session` has failed, and that the</span>
<span class="sd">        :meth:`_orm.Session.rollback` method must be emitted in order to</span>
<span class="sd">        fully roll back the transaction.</span>

<span class="sd">        If this :class:`_orm.Session` is not in a transaction at all, the</span>
<span class="sd">        :class:`_orm.Session` will autobegin when it is first used, so in this</span>
<span class="sd">        case :attr:`_orm.Session.is_active` will return True.</span>

<span class="sd">        Otherwise, if this :class:`_orm.Session` is within a transaction,</span>
<span class="sd">        and that transaction has not been rolled back internally, the</span>
<span class="sd">        :attr:`_orm.Session.is_active` will also return True.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`faq_session_rollback`</span>

<span class="sd">            :meth:`_orm.Session.in_transaction`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transaction</span><span class="o">.</span><span class="n">is_active</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dirty_states</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">InstanceState</span><span class="p">[</span><span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The set of all persistent states considered dirty.</span>

<span class="sd">        This method returns all states that were modified including</span>
<span class="sd">        those that were possibly deleted.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_dirty_states</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IdentitySet</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The set of all persistent instances considered dirty.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            some_mapped_object in session.dirty</span>

<span class="sd">        Instances are considered dirty when they were modified but not</span>
<span class="sd">        deleted.</span>

<span class="sd">        Note that this &#39;dirty&#39; calculation is &#39;optimistic&#39;; most</span>
<span class="sd">        attribute-setting or collection modification operations will</span>
<span class="sd">        mark an instance as &#39;dirty&#39; and place it in this set, even if</span>
<span class="sd">        there is no net change to the attribute&#39;s value.  At flush</span>
<span class="sd">        time, the value of each attribute is compared to its</span>
<span class="sd">        previously saved value, and if there&#39;s no net change, no SQL</span>
<span class="sd">        operation will occur (this is a more expensive operation so</span>
<span class="sd">        it&#39;s only done at flush time).</span>

<span class="sd">        To check if an instance has actionable net changes to its</span>
<span class="sd">        attributes, use the :meth:`.Session.is_modified` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IdentitySet</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_states</span>
                <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IdentitySet</span><span class="p">:</span>
        <span class="s2">&quot;The set of all instances marked as &#39;deleted&#39; within this ``Session``&quot;</span>

        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">IdentitySet</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">IdentitySet</span><span class="p">:</span>
        <span class="s2">&quot;The set of all instances marked as &#39;new&#39; within this ``Session``.&quot;</span>

        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">IdentitySet</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>


<span class="n">_S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;_S&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;Session&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="sessionmaker">
<a class="viewcode-back" href="../../../CveXplore/database/sessionmaker.html#CveXplore.database.connection.sqlbase.connection.sessionmaker">[docs]</a>
<span class="k">class</span> <span class="nc">sessionmaker</span><span class="p">(</span><span class="n">_SessionClassMethods</span><span class="p">,</span> <span class="n">Generic</span><span class="p">[</span><span class="n">_S</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A configurable :class:`.Session` factory.</span>

<span class="sd">    The :class:`.sessionmaker` factory generates new</span>
<span class="sd">    :class:`.Session` objects when called, creating them given</span>
<span class="sd">    the configurational arguments established here.</span>

<span class="sd">    e.g.::</span>

<span class="sd">        from sqlalchemy import create_engine</span>
<span class="sd">        from sqlalchemy.orm import sessionmaker</span>

<span class="sd">        # an Engine, which the Session will use for connection</span>
<span class="sd">        # resources</span>
<span class="sd">        engine = create_engine(&#39;postgresql+psycopg2://scott:tiger@localhost/&#39;)</span>

<span class="sd">        Session = sessionmaker(engine)</span>

<span class="sd">        with Session() as session:</span>
<span class="sd">            session.add(some_object)</span>
<span class="sd">            session.add(some_other_object)</span>
<span class="sd">            session.commit()</span>

<span class="sd">    Context manager use is optional; otherwise, the returned</span>
<span class="sd">    :class:`_orm.Session` object may be closed explicitly via the</span>
<span class="sd">    :meth:`_orm.Session.close` method.   Using a</span>
<span class="sd">    ``try:/finally:`` block is optional, however will ensure that the close</span>
<span class="sd">    takes place even if there are database errors::</span>

<span class="sd">        session = Session()</span>
<span class="sd">        try:</span>
<span class="sd">            session.add(some_object)</span>
<span class="sd">            session.add(some_other_object)</span>
<span class="sd">            session.commit()</span>
<span class="sd">        finally:</span>
<span class="sd">            session.close()</span>

<span class="sd">    :class:`.sessionmaker` acts as a factory for :class:`_orm.Session`</span>
<span class="sd">    objects in the same way as an :class:`_engine.Engine` acts as a factory</span>
<span class="sd">    for :class:`_engine.Connection` objects.  In this way it also includes</span>
<span class="sd">    a :meth:`_orm.sessionmaker.begin` method, that provides a context</span>
<span class="sd">    manager which both begins and commits a transaction, as well as closes</span>
<span class="sd">    out the :class:`_orm.Session` when complete, rolling back the transaction</span>
<span class="sd">    if any errors occur::</span>

<span class="sd">        Session = sessionmaker(engine)</span>

<span class="sd">        with Session.begin() as session:</span>
<span class="sd">            session.add(some_object)</span>
<span class="sd">            session.add(some_other_object)</span>
<span class="sd">        # commits transaction, closes session</span>

<span class="sd">    .. versionadded:: 1.4</span>

<span class="sd">    When calling upon :class:`_orm.sessionmaker` to construct a</span>
<span class="sd">    :class:`_orm.Session`, keyword arguments may also be passed to the</span>
<span class="sd">    method; these arguments will override that of the globally configured</span>
<span class="sd">    parameters.  Below we use a :class:`_orm.sessionmaker` bound to a certain</span>
<span class="sd">    :class:`_engine.Engine` to produce a :class:`_orm.Session` that is instead</span>
<span class="sd">    bound to a specific :class:`_engine.Connection` procured from that engine::</span>

<span class="sd">        Session = sessionmaker(engine)</span>

<span class="sd">        # bind an individual session to a connection</span>

<span class="sd">        with engine.connect() as connection:</span>
<span class="sd">            with Session(bind=connection) as session:</span>
<span class="sd">                # work with session</span>

<span class="sd">    The class also includes a method :meth:`_orm.sessionmaker.configure`, which</span>
<span class="sd">    can be used to specify additional keyword arguments to the factory, which</span>
<span class="sd">    will take effect for subsequent :class:`.Session` objects generated. This</span>
<span class="sd">    is usually used to associate one or more :class:`_engine.Engine` objects</span>
<span class="sd">    with an existing</span>
<span class="sd">    :class:`.sessionmaker` factory before it is first used::</span>

<span class="sd">        # application starts, sessionmaker does not have</span>
<span class="sd">        # an engine bound yet</span>
<span class="sd">        Session = sessionmaker()</span>

<span class="sd">        # ... later, when an engine URL is read from a configuration</span>
<span class="sd">        # file or other events allow the engine to be created</span>
<span class="sd">        engine = create_engine(&#39;sqlite:///foo.db&#39;)</span>
<span class="sd">        Session.configure(bind=engine)</span>

<span class="sd">        sess = Session()</span>
<span class="sd">        # work with session</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :ref:`session_getting` - introductory text on creating</span>
<span class="sd">        sessions using :class:`.sessionmaker`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">class_</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">_S</span><span class="p">]</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_SessionBind</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">class_</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">_S</span><span class="p">],</span>
        <span class="n">autoflush</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">expire_on_commit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_InfoType</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">):</span> <span class="o">...</span>

    <span class="nd">@overload</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">:</span> <span class="s2">&quot;sessionmaker[Session]&quot;</span><span class="p">,</span>
        <span class="n">bind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_SessionBind</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">autoflush</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">expire_on_commit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="n">info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_InfoType</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">):</span> <span class="o">...</span>

<div class="viewcode-block" id="sessionmaker.__init__">
<a class="viewcode-back" href="../../../CveXplore/database/sessionmaker.__init__.html#CveXplore.database.connection.sqlbase.connection.sessionmaker.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bind</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_SessionBind</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">class_</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">_S</span><span class="p">]</span> <span class="o">=</span> <span class="n">Session</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
        <span class="n">autoflush</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">expire_on_commit</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">_InfoType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Construct a new :class:`.sessionmaker`.</span>

<span class="sd">        All arguments here except for ``class_`` correspond to arguments</span>
<span class="sd">        accepted by :class:`.Session` directly.  See the</span>
<span class="sd">        :meth:`.Session.__init__` docstring for more details on parameters.</span>

<span class="sd">        :param bind: a :class:`_engine.Engine` or other :class:`.Connectable`</span>
<span class="sd">         with</span>
<span class="sd">         which newly created :class:`.Session` objects will be associated.</span>
<span class="sd">        :param class\_: class to use in order to create new :class:`.Session`</span>
<span class="sd">         objects.  Defaults to :class:`.Session`.</span>
<span class="sd">        :param autoflush: The autoflush setting to use with newly created</span>
<span class="sd">         :class:`.Session` objects.</span>

<span class="sd">         .. seealso::</span>

<span class="sd">            :ref:`session_flushing` - additional background on autoflush</span>

<span class="sd">        :param expire_on_commit=True: the</span>
<span class="sd">         :paramref:`_orm.Session.expire_on_commit` setting to use</span>
<span class="sd">         with newly created :class:`.Session` objects.</span>

<span class="sd">        :param info: optional dictionary of information that will be available</span>
<span class="sd">         via :attr:`.Session.info`.  Note this dictionary is *updated*, not</span>
<span class="sd">         replaced, when the ``info`` parameter is specified to the specific</span>
<span class="sd">         :class:`.Session` construction operation.</span>

<span class="sd">        :param \**kw: all other keyword arguments are passed to the</span>
<span class="sd">         constructor of newly created :class:`.Session` objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;bind&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;autoflush&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">autoflush</span>
        <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;expire_on_commit&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expire_on_commit</span>
        <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">=</span> <span class="n">kw</span>
        <span class="c1"># make our own subclass of the given class, so that</span>
        <span class="c1"># events can be associated with it specifically.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">class_</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="n">class_</span><span class="p">,),</span> <span class="p">{})</span></div>


<div class="viewcode-block" id="sessionmaker.begin">
<a class="viewcode-back" href="../../../CveXplore/database/sessionmaker.begin.html#CveXplore.database.connection.sqlbase.connection.sessionmaker.begin">[docs]</a>
    <span class="k">def</span> <span class="nf">begin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">contextlib</span><span class="o">.</span><span class="n">AbstractContextManager</span><span class="p">[</span><span class="n">_S</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Produce a context manager that both provides a new</span>
<span class="sd">        :class:`_orm.Session` as well as a transaction that commits.</span>


<span class="sd">        e.g.::</span>

<span class="sd">            Session = sessionmaker(some_engine)</span>

<span class="sd">            with Session.begin() as session:</span>
<span class="sd">                session.add(some_object)</span>

<span class="sd">            # commits transaction, closes session</span>

<span class="sd">        .. versionadded:: 1.4</span>


<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">session</span> <span class="o">=</span> <span class="bp">self</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">session</span><span class="o">.</span><span class="n">_maker_context_manager</span><span class="p">()</span></div>


<div class="viewcode-block" id="sessionmaker.__call__">
<a class="viewcode-back" href="../../../CveXplore/database/sessionmaker.__call__.html#CveXplore.database.connection.sqlbase.connection.sessionmaker.__call__">[docs]</a>
    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">local_kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_S</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Produce a new :class:`.Session` object using the configuration</span>
<span class="sd">        established in this :class:`.sessionmaker`.</span>

<span class="sd">        In Python, the ``__call__`` method is invoked on an object when</span>
<span class="sd">        it is &quot;called&quot; in the same way as a function::</span>

<span class="sd">            Session = sessionmaker(some_engine)</span>
<span class="sd">            session = Session()  # invokes sessionmaker.__call__()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;info&quot;</span> <span class="ow">and</span> <span class="s2">&quot;info&quot;</span> <span class="ow">in</span> <span class="n">local_kw</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">local_kw</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">])</span>
                <span class="n">local_kw</span><span class="p">[</span><span class="s2">&quot;info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">local_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_</span><span class="p">(</span><span class="o">**</span><span class="n">local_kw</span><span class="p">)</span></div>


<div class="viewcode-block" id="sessionmaker.configure">
<a class="viewcode-back" href="../../../CveXplore/database/sessionmaker.configure.html#CveXplore.database.connection.sqlbase.connection.sessionmaker.configure">[docs]</a>
    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kw</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;(Re)configure the arguments for this sessionmaker.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            Session = sessionmaker()</span>

<span class="sd">            Session.configure(bind=create_engine(&#39;sqlite://&#39;))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_kw</span><span class="p">)</span></div>


<div class="viewcode-block" id="sessionmaker.__repr__">
<a class="viewcode-back" href="../../../CveXplore/database/sessionmaker.__repr__.html#CveXplore.database.connection.sqlbase.connection.sessionmaker.__repr__">[docs]</a>
    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(class_=</span><span class="si">%r</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span>
        <span class="p">)</span></div>
</div>



<span class="k">def</span> <span class="nf">close_all_sessions</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Close all sessions in memory.</span>

<span class="sd">    This function consults a global registry of all :class:`.Session` objects</span>
<span class="sd">    and calls :meth:`.Session.close` on them, which resets them to a clean</span>
<span class="sd">    state.</span>

<span class="sd">    This function is not for general use but may be useful for test suites</span>
<span class="sd">    within the teardown scheme.</span>

<span class="sd">    .. versionadded:: 1.3</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">sess</span> <span class="ow">in</span> <span class="n">_sessions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">sess</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">make_transient</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Alter the state of the given instance so that it is :term:`transient`.</span>

<span class="sd">    .. note::</span>

<span class="sd">        :func:`.make_transient` is a special-case function for</span>
<span class="sd">        advanced use cases only.</span>

<span class="sd">    The given mapped instance is assumed to be in the :term:`persistent` or</span>
<span class="sd">    :term:`detached` state.   The function will remove its association with any</span>
<span class="sd">    :class:`.Session` as well as its :attr:`.InstanceState.identity`. The</span>
<span class="sd">    effect is that the object will behave as though it were newly constructed,</span>
<span class="sd">    except retaining any attribute / collection values that were loaded at the</span>
<span class="sd">    time of the call.   The :attr:`.InstanceState.deleted` flag is also reset</span>
<span class="sd">    if this object had been deleted as a result of using</span>
<span class="sd">    :meth:`.Session.delete`.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        :func:`.make_transient` does **not** &quot;unexpire&quot; or otherwise eagerly</span>
<span class="sd">        load ORM-mapped attributes that are not currently loaded at the time</span>
<span class="sd">        the function is called.   This includes attributes which:</span>

<span class="sd">        * were expired via :meth:`.Session.expire`</span>

<span class="sd">        * were expired as the natural effect of committing a session</span>
<span class="sd">          transaction, e.g. :meth:`.Session.commit`</span>

<span class="sd">        * are normally :term:`lazy loaded` but are not currently loaded</span>

<span class="sd">        * are &quot;deferred&quot; (see :ref:`orm_queryguide_column_deferral`) and are</span>
<span class="sd">          not yet loaded</span>

<span class="sd">        * were not present in the query which loaded this object, such as that</span>
<span class="sd">          which is common in joined table inheritance and other scenarios.</span>

<span class="sd">        After :func:`.make_transient` is called, unloaded attributes such</span>
<span class="sd">        as those above will normally resolve to the value ``None`` when</span>
<span class="sd">        accessed, or an empty collection for a collection-oriented attribute.</span>
<span class="sd">        As the object is transient and un-associated with any database</span>
<span class="sd">        identity, it will no longer retrieve these values.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.make_transient_to_detached`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_state_session</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">_expunge_states</span><span class="p">([</span><span class="n">state</span><span class="p">])</span>

    <span class="c1"># remove expired state</span>
    <span class="n">state</span><span class="o">.</span><span class="n">expired_attributes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="c1"># remove deferred callables</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">callables</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">callables</span>

    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span>


<span class="k">def</span> <span class="nf">make_transient_to_detached</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Make the given transient instance :term:`detached`.</span>

<span class="sd">    .. note::</span>

<span class="sd">        :func:`.make_transient_to_detached` is a special-case function for</span>
<span class="sd">        advanced use cases only.</span>

<span class="sd">    All attribute history on the given instance</span>
<span class="sd">    will be reset as though the instance were freshly loaded</span>
<span class="sd">    from a query.  Missing attributes will be marked as expired.</span>
<span class="sd">    The primary key attributes of the object, which are required, will be made</span>
<span class="sd">    into the &quot;key&quot; of the instance.</span>

<span class="sd">    The object can then be added to a session, or merged</span>
<span class="sd">    possibly with the load=False flag, at which point it will look</span>
<span class="sd">    as if it were loaded that way, without emitting SQL.</span>

<span class="sd">    This is a special use case function that differs from a normal</span>
<span class="sd">    call to :meth:`.Session.merge` in that a given persistent state</span>
<span class="sd">    can be manufactured without any SQL calls.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.make_transient`</span>

<span class="sd">        :meth:`.Session.enable_relationship_loading`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">or</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;Given object must be transient&quot;</span><span class="p">)</span>
    <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_from_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">_deleted</span>
    <span class="n">state</span><span class="o">.</span><span class="n">_commit_all</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span>
    <span class="n">state</span><span class="o">.</span><span class="n">_expire_attributes</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">unloaded</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">object_session</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Session</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the :class:`.Session` to which the given instance belongs.</span>

<span class="sd">    This is essentially the same as the :attr:`.InstanceState.session`</span>
<span class="sd">    accessor.  See that attribute for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">err</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_state_session</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>


<span class="n">_new_sessionid</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">counter</span><span class="p">()</span>
</code></pre></div>

  <hr>
<div class="md-source-file">
  <small>
    
      Last update:
      Jul 03, 2024
    
  </small>
</div>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

        </div>
        
          <a href="#" class="md-top md-icon" data-md-component="top" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            Back to top
          </a>
        
      </main>
      
        <footer class="md-footer">
  
  
  
  <div class="md-footer-meta md-typeset">
    
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-footer-copyright__highlight">
        &#169; Copyright 2020, Paul Tikken.
        
    </div>
  
    Created using
    <a href="https://www.sphinx-doc.org/" target="_blank" rel="noopener">Sphinx</a>
    7.3.7.
     and
    <a href="https://github.com/jbms/sphinx-immaterial/" target="_blank" rel="noopener">Sphinx-Immaterial</a>
  
</div>
      
    </div>
    
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.expand", "navigation.sections", "navigation.top", "search.share", "toc.follow", "toc.sticky", "content.tabs.link", "announce.dismiss"], "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
      
        <script src="../../../_static/sphinx_immaterial_theme.f9d9eeeb247ace16c.min.js?v=8ec58cb5"></script>
    
  </body>
</html>